{"pages":[{"title":"","text":"个人简介 分享很喜欢的**老罗**的一段话： “每一个生命来到世间都注定改变世界，别无选择。要么变得好一点，要么变得坏一点。你如果走进社会为了生存为了什么不要脸的理由，变成了一个恶心的成年人社会中的一员，那你就把这个世界变得恶心了一点点。如果你一生刚正不阿，如果你一生耿直，没有做任何恶心的事情，没做对别人有害的事情，一辈子拼了老命勉强把自己身边的几个人照顾好了，没有成名没有发财，没有成就伟大的事业，然后耿着脖子一生正直，到了七八十岁耿着脖子去世了。你这一生是不是没有改变世界？你还是改变世界了，你把这个世界变得美好了一点点。因为世界上又多了一个好人。“ 善恶终有报,天道好轮回。不信抬头看,苍天饶过谁。无论何时何地，我们都要保持一颗积极乐观、善良感恩的心。但行好事莫问前程，永远年轻，永远热内盈眶，永远保持正能量。💪💪💪💪💪💪冲鸭！！！！ -&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;个人信息：计算机科学与技术专业从事JAVA后端开发码畜一枚坚信代码改变世界 博客信息 网站采用的Icarus主题 追求尽可能的简洁，清晰，易用。 在Icarus主题之上进行了部分修改。 更新日志：–2020.01.18：icarus3.0适配–2019.11.17：增加深色主题开关–2019.10.30：去图，精简卡片–2019.10.22：改版部分显示，优化速度–2019.10.16：文章列表加上评论数显示–2019.10.13：改版评论–2019.09.25：图片、资源接入CDN免费jsDelivr、文章加入置顶–2019.09.19：开源博客代码–2019.09.19：修改布局，拉伸布局，更宽的展示–2019.09.18：修改友链ui为一行三个，并适配移动端，暗黑模式文章增加评论链接，增加留言链接–2019.09.14：增加精简next主题–2019.09.14：利用中秋节放假，重做了首页的热门推荐、加个widget最新评论框、归档页加入文章贡献概览面板 本站推荐索引 博客主题相关 github Issue 作为博客微型数据库的应用 github page网站cdn优化加速 博客源码分享 博客换肤的一种实现方式思路 博客中gitalk最新评论的获取 博客图片上传picgo工具github图传使用 安装、部分配置icarus主题中文版 技术知识点 Java并发知识点 法律法规 法律法规数据库 中华人民共和国国旗法 中华人民共和国宪法 中华人民共和国消费者权益保护法 中华人民共和国刑事诉讼法 中华人民共和国婚姻法 中华人名共和国网络安全法 中华人民共和国劳动法 其他 网易云音乐歌单分享 计划2020计划 2019.12.31 2020-GOALS 跑两三场马拉松 2019计划 2018.12.31/21:59:00-&gt;更新于2019.12.31 2019-GOALS 购买的专业书籍至少看完一遍（并发、重构、设计模式…）-&gt; 95% 额外： 追了很多剧 总结： 有优点有缺点，没坚持下来的还是太多，追了太多剧。以后多学习，多思考！ 时间轴记录","link":"/about/index.html"},{"title":"","text":"申请友链须知 原则上只和技术类博客交换，但不包括含有和色情、暴力、政治敏感的网站。 不和剽窃、侵权、无诚信的网站交换，优先和具有原创作品的网站交换。 申请请提供：站点名称、站点链接、站点描述、logo或头像（不要设置防盗链）。 排名不分先后，刷新后重排，更新信息后请留言告知。 会定期清理很久很久不更新的、不符合要求的友链，不再另行通知。 本站不存储友链图片，如果友链图片换了无法更新。图片裂了的会替换成默认图，需要更换的请留言告知。 本站友链信息如下，申请友链前请先添加本站信息： 网站图标：https://removeif.github.io/images/avatar.jpg 网站名称：辣椒の酱 网站地址：https://removeif.github.io 网站简介：后端开发，技术分享 加载中，稍等几秒...","link":"/friend/index.html"},{"title":"","text":"来而不往非礼也畅所欲言，有留必应","link":"/message/index.html"},{"title":"","text":"碎碎念 tips：github登录后按时间正序查看、可点赞加❤️、本插件地址..「+99次查看」 碎碎念加载中，请稍等... $.getScript(\"/js/gitalk_self.min.js\", function () { var gitalk = new Gitalk({ clientID: '46a9f3481b46ea0129d8', clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24', id: '666666', repo: 'issue_database', owner: 'removeif', admin: \"removeif\", createIssueManually: true, distractionFreeMode: false }); gitalk.render('comment-container1'); });","link":"/self-talking/index.html"},{"title":"","text":"唐艺昕 李沁 李一桐 gakki 图片搜集于互联网，侵权请留言，马上处理😊。","link":"/album/index.html"},{"title":"音乐歌单收藏","text":"--- 温馨提示：选择喜欢的音乐双击播放，由于版权原因部分不能播放。如果喜欢歌单收藏一下，去网易云都能播放哟！","link":"/music/index.html"},{"title":"","text":"&nbsp;&nbsp;听听音乐 音乐播放器由mePlayer提供，布局参照网友博客所作，感谢作者的辛勤付出。更多音乐分享请查看歌单。 &nbsp;&nbsp;看看视频 ->点击以下条目开始播放视频,向下滑动查看更多","link":"/media/index.html"}],"posts":[{"title":"Fri Dec 22 2017 00:00:00 GMT+0800 (中国标准时间)","text":"图片拉伸很难看","link":"/2017/12/23/internet-bar/"},{"title":"后天就要回家了，一年没回去了。","text":"package&nbsp;life.domain; public&nbsp;class&nbsp;MyHome&nbsp;extends&nbsp;Home&nbsp;{ private&nbsp;People&nbsp;grandpa; private&nbsp;People&nbsp;grandma; private&nbsp;People&nbsp;father; private&nbsp;People&nbsp;mother; private&nbsp;People&nbsp;sister; private&nbsp;Me&nbsp;me; public&nbsp;People&nbsp;getGrandpa()&nbsp;{ return&nbsp;grandpa; } public&nbsp;void&nbsp;setGrandpa(People&nbsp;grandpa)&nbsp;{ this.grandpa&nbsp;=&nbsp;grandpa; } public&nbsp;People&nbsp;getGrandma()&nbsp;{ return&nbsp;grandma; } public&nbsp;void&nbsp;setGrandma(People&nbsp;grandma)&nbsp;{ this.grandma&nbsp;=&nbsp;grandma; } public&nbsp;People&nbsp;getFather()&nbsp;{ return&nbsp;father; } public&nbsp;void&nbsp;setFather(People&nbsp;father)&nbsp;{ this.father&nbsp;=&nbsp;father; } public&nbsp;People&nbsp;getMother()&nbsp;{ return&nbsp;mother; } public&nbsp;void&nbsp;setMother(People&nbsp;mother)&nbsp;{ this.mother&nbsp;=&nbsp;mother; } public&nbsp;People&nbsp;getSister()&nbsp;{ return&nbsp;sister; } public&nbsp;void&nbsp;setSister(People&nbsp;sister)&nbsp;{ this.sister&nbsp;=&nbsp;sister; } public&nbsp;Me&nbsp;getMe()&nbsp;{ return&nbsp;me; } public&nbsp;void&nbsp;setMe(Me&nbsp;me)&nbsp;{ this.me&nbsp;=&nbsp;me; } }对这个世界如果你有太多的抱怨&nbsp;跌倒了 就不敢继续往前走&nbsp;为什么 人要这么的脆弱 堕落&nbsp;请你打开电视看看&nbsp;多少人为生命在努力勇敢的走下去&nbsp;我们是不是该知足&nbsp;珍惜一切 就算没有拥有&nbsp;还记得你说家是唯一的城堡&nbsp;随着稻香河流继续奔跑&nbsp;微微笑 小时候的梦我知道&nbsp;不要哭让萤火虫带著你逃跑&nbsp;乡间的歌谣永远的依靠&nbsp;回家吧 回到最初的美好&nbsp;不要这么容易就想放弃 就像我说的&nbsp;追不到的梦想 换个梦不就得了&nbsp;为自己的人生鲜艳上色&nbsp;先把爱涂上喜欢的颜色&nbsp;笑一个吧 功成名就不是目的&nbsp;让自己快乐快乐这才叫做意义&nbsp;童年的纸飞机 现在终于飞回我手里&nbsp;所谓的那快乐 赤脚在田里追蜻蜓追到累了&nbsp;偷摘水果被蜜蜂给叮到怕了&nbsp;谁在偷笑呢&nbsp;我靠着稻草人吹着风唱着歌睡着了&nbsp;哦 哦 午后吉它在虫鸣中更清脆&nbsp;哦 哦 阳光洒在路上就不怕心碎&nbsp;珍惜一切 就算没有拥有&nbsp;还记得你说家是唯一的城堡&nbsp;随着稻香河流继续奔跑&nbsp;微微笑 小时候的梦我知道&nbsp;不要哭让萤火虫带著你逃跑&nbsp;乡间的歌谣永远的依靠&nbsp;回家吧 回到最初的美好&nbsp;还记得你说家是唯一的城堡&nbsp;随着稻香河流继续奔跑&nbsp;微微笑 小时候的梦我知道&nbsp;不要哭让萤火虫带著你逃跑&nbsp;乡间的歌谣永远的依靠&nbsp;回家吧 回到最初的美好。","link":"/2018/02/05/go-home/"},{"title":"2019-05-28-00-27","text":"最近 最近没什么变化 自己还是这个样子 好像有了一些变化 会碰到一个人，因此而烦恼 但我却无力改变，是否孤独终老 爱生活 爱自己 最好的礼物，就是更好的自己 我得自律一点 &nbsp; 争取早点搞好，懒懒散散 &nbsp; 真想做一只舔狗。 &nbsp; 晚安，争取梦想实现","link":"/2019/05/29/00-27-my-name-is-iureh/"},{"title":"明天中午回广州的火车票，不想回去。","text":"不想离开这里。为什么偏要选择背井离乡。","link":"/2018/02/20/I-dont-want-to-go/"},{"title":"有点累呀。","text":"这一周的前三天，都在做日程发布的后台页面。 相当于又是一个重做，哎。做起来真的费力。","link":"/2018/03/23/a-little-tired/"},{"title":"35 个 Java 代码优化魔鬼细节","text":"source: 雨梦coderhttps://mp.weixin.qq.com/s/GqZ4E2QG6h58DeKFyf8Pbg 前言代码 优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大 海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。 代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每 个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。 代码优化的目标是： 减小代码的体积 提高代码运行的效率 代码优化细节 1、尽量指定类、方法的final修饰符 带有final修饰符的类是不可派生的。在Java核心API中，有许多应用final的例子，例如java.lang.String，整个类都是final的。为类指定final修饰符可以让类不可以被 继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联 对于提升Java运行效率作用重大，具体参见Java运行期优化。此举能够使性能平均提高50% 。 2、尽量重用对象 特别是String对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行 垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。 3、尽可能使用局部变量 调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随 着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。 4、及时关闭流 Java编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严 重的后果。如果条件允许，即JDK7以上，强烈建议使用try-with-resources。 5、尽量减少对变量的重复计算 明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作： 建议替换为： 这样，在list.size很大的时候，就减少了很多的消耗 6、尽量采用懒加载的策略，即在需要的时候才创建* 例如： 建议替换为： 7、慎用异常 异常对性能不利。抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace的本地同步方法，fillInStackTrace方法检查堆栈，收集调用 跟踪信息。只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。异常只能用于错误处理，不应该用来控制程序流程。 8、不要在循环中使用try…catch…，应该把其放在最外层 除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了。 9、如果能估计到待添加的内容长度，为底层以数组方式实现的集合、工具类指定初始长度 比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以StringBuilder为例： （1）StringBuilder // 默认分配16个字符的空间 （2）StringBuilder(int size) // 默认分配size个字符的空间 （3）StringBuilder(String str) // 默认分配16个字符+str.length个字符空间 可以通过类（这里指的不仅仅是上面的StringBuilder）的来设定它的初始化容量，这样可以明显地提升性能。比如StringBuilder吧，length表示当前的StringBuilder能 保持的字符数量。因为当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一 个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中—-这是十分耗费性能的一个操作。试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最 接近5000的2次幂是4096，每次扩容加的2不管，那么： （1）在4096 的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上 的空间； （2）把原来的4096个字符拷贝到新的的字符数组中去。 这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。但是，注意，像 HashMap这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如 果能估计到有2000个元素，设置成new HashMap(128)、new HashMap(256)都可以。 10、当复制大量数据时，使用System.arraycopy命令 11、乘法和除法使用移位操作例如： 用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为： 移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。 12、循环内不要不断创建对象引用例如： 这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为： 这样的话，内存中只有一份Object对象引用，每次new Object的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份，这样就大大节省了内存空间了。 13、基于效率和类型检查的考虑，应该尽可能使用array，无法确定数组大小时才使用ArrayList 14、尽量使用HashMap、ArrayList、StringBuilder，除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销 15、不要将数组声明为public static final因为这毫无意义，这样只是定义了引用为static final，数组的内容还是可以随意改变的，将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变 。 16、尽量在合适的场合使用单例使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：（1）控制资源的使用，通过线程同步来控制资源的并发访问（2）控制实例的产生，以达到节约资源的目的（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信 17、尽量避免随意使用静态变量要知道，当某个对象被定义为static的变量所引用，那么gc通常是不会回收这个对象所占有的堆内存的，如： 此时静态变量b的生命周期与A类相同，如果A类不被卸载，那么引用B指向的B对象会常驻内存，直到程序终止。 18、及时清除不再需要的Session为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转 移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先 被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用HttpSession的invalidate方法清除会话。 19、实现RandomAccess接口的集合比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历这是JDK推荐给用户的。JDK API对于RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为， 从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现RandomAccess接口的类实例，假如是随机访问的，使用普通for循环效率将高于使用foreach 循环；反过来，如果是顺序访问的，则使用Iterator会效率更高。可以使用类似如下的代码作判断： foreach循环的底层实现原理就是迭代器Iterator，参见Java语法糖1：可变长度参数以及foreach循环原理。所以后半句”反过来，如果是顺序访问的，则使用Iterator会 效率更高”的意思就是顺序访问的那些类实例，使用foreach循环去遍历。 20、使用同步代码块替代同步方法这点在多线程模块中的synchronized锁方法块一文中已经讲得很清楚了，除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同 步的代码也进行了同步，影响了代码执行效率。 21、将常量声明为static final，并以大写命名这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量。 22、不要创建一些不使用的对象，不要导入一些不使用的类这毫无意义，如果代码中出现”The value of the local variable i is not used”、”The import java.util is never used”，那么请删除这些无用的内容 23、程序运行过程中避免使用反射关于，请参见反射。反射是Java提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是Method的 invoke方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时 候获取最快的响应速度，并不关心对端的项目启动花多久时间。 24、使用数据库连接池和线程池这两个池都是用于重用对象的，前者可以避免频繁地打开和关闭连接，后者可以避免频繁地创建和销毁线程。 25、使用带缓冲的输入输出流进行IO操作带缓冲的输入输出流，即BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升IO效率。 26、顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了。 27、不要让public方法中有太多的形参public方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：1、违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合2、参数太多势必导致方法调用的出错概率增加至于这个”太多”指的是多少个，3、4个吧。比如我们用JDBC写一个insertStudentInfo方法，有10个学生信息字段要插如Student表中，可以把这10个参数封装在一个实体 类中，作为insert方法的形参。 28、字符串变量和字符串常量equals的时候将字符串常量写在前面这是一个比较常见的小技巧了，如果有以下代码： 建议修改为： 这么做主要是可以避免空指针异常。 29、请知道，在java中if (i == 1)和if (1 == i)是没有区别的，但从阅读习惯上讲，建议使用前者平时有人问，”if (i == 1)”和”if (1== i)”有没有区别，这就要从C/C++讲起。在C/C++中，”if (i == 1)”判断条件成立，是以0与非0为基准的，0表示false，非0表示true，如果有这么一段代码： C/C++判断”i==1″不成立，所以以0表示，即false。但是如果： 万一程序员一个不小心，把”if (i == 1)”写成”if (i = 1)”，这样就有问题了。在if之内将i赋值为1，if判断里面的内容非0，返回的就是true了，但是明明i为2，比 较的值是1，应该返回的false。这种情况在C/C++的开发中是很可能发生的并且会导致一些难以理解的错误产生，所以，为了避免开发者在if语句中不正确的赋值操作，建 议将if语句写为： 这样，即使开发者不小心写成了”1 = i”，C/C++编译器也可以第一时间检查出来，因为我们可以对一个变量赋值i为1，但是不能对一个常量赋值1为i。但是，在Java中，C/C++这种”if (i = 1)”的语法是不可能出现的，因为一旦写了这种语法，Java就会编译报错”Type mismatch: cannot convert from int to boolean ”。但是，尽管Java的”if (i == 1)”和”if (1 == i)”在语义上没有任何区别，但是从阅读习惯上讲，建议使用前者会更好些。 30、不要对数组使用toString方法看一下对数组使用toString打印出来的是什么： 结果是： 本意是想打印出数组内容，却有可能因为数组引用is为空而导致空指针异常。不过虽然对数组toString没有意义，但是对集合toString是可以打印出集合里面的内容的，因 为集合的父类AbstractCollections重写了Object的toString方法。 31、不要对超出范围的基本数据类型做向下强制转型这绝不会得到想要的结果： 我们可能期望得到其中的某几位，但是结果却是：1942892530解释一下。Java中long是8个字节64位的，所以12345678901234在计算机中的表示应该是：0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010一个int型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：0111 0011 1100 1110 0010 1111 1111 0010这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：1、整型默认的数据类型是int，long l = 12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是 double，所以定义float的时候要写成””float f = 3.5f”2、接下来再写一句”int ii = l + i;”会报错，因为long + int是一个long，不能赋值给int 32、公用的集合类中不使用的数据一定要及时remove掉如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据 不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。 33、把一个基本数据类型转为字符串，基本数据类型.toString是最快的方式、String.valueOf次之、数据+””最慢把一个基本数据类型转为一般有三种方式，我有一个Integer型数据i，可以使用i.toString、String.valueOf(i)、i+””三种方式，三种方式的效率如何，看一个测试： 运行结果为： 所以以后遇到把一个基本数据类型转为String的时候，优先考虑使用toString方法。至于为什么，很简单：1、String.valueOf方法底层调用了Integer.toString方法，但是会在调用前做空判断2、Integer.toString方法就不说了，直接调用了3、i + “”底层使用了StringBuilder实现，先用append方法拼接，再用toString方法获取字符串三者对比下来，明显是2最快、1次之、3最慢。 34、使用最有效率的方式去遍历Map遍历Map的方式有很多，通常场景下我们需要的是遍历Map中的Key和Value，那么推荐使用的、效率最高的方式是： 如果你只是想遍历一下这个Map的key值，那用”Set keySet = hm.keySet;”会比较合适一些 35、对资源的close建议分开操作意思是，比如我有这么一段代码： 建议修改为： 虽然有些麻烦，却能避免资源泄露。我想，如果没有修改过的代码，万一XXX.close抛异常了，那么就进入了cath块中了，YYY.close不会执行，YYY这块资源就不会回收了 ，一直占用着，这样的代码一多，是可能引起资源句柄泄露的。而改为上面的写法之后，就保证了无论如何XXX和YYY都会被close掉。如果JDK7以上，强烈建议使用try-with-resources。","link":"/2020/04/11/Java-code-optimization/"},{"title":"activemq初识","text":"jms简介 jms(java message service)java消息服务，它主要用于生产者和消费者的消息传递。生产者负责产生消息，而消费者负责接收消息。把它应用到实际的业务需求中可以在特定的时候利用生产者生成消息，并进行发送，对应的消费者在接收到对应的消息后去完成对应的业务逻辑。对于消息的传递有两种类型，一种是点对点的，即一个生产者和一个消费者一一对应；另一种是发布/订阅模式，即一个生产者产生消息并进行发送后，可以由多个消费者进行接收。 activemq简介 activemq主要用在异步处理、消息通讯、流量销峰、应用解耦 1、点对点，队列 2、一对多，topic activemq管理页面：hr2812.cn:8681/admin，admin，admin &nbsp;","link":"/2019/03/03/activemq-frist/"},{"title":"关于微服务","text":"1、什么是微服务？ 以前的模式是所有代码在同一工程中，部署在同一个服务器上。会出现同一个项目不同的功能模块抢占资源的情况。 微服务就是把不同业务功能拆分为不同模块，分为一个个的子项目，分开部署。服务之前相互调用。 常用的微服务框架Dubbo、SpringCloud等。 之前都是单体架构：所有代码都在同一个项目中，方便管理。当项目越来越大时，一个模块挂掉其他也会跟着挂掉。 项目过于臃肿 资源无法隔离 无法灵活扩展","link":"/2019/03/07/about-microservice/"},{"title":"working note","text":"working&nbsp;note 1.不注重流程，项目中事情的先后顺序。 2.技术能力一般，对于一些错误出现，分析不到位。 3.需求理解能力一般。 4.基本全靠混，代码理解能力和业务理解能力都不怎么样。 ##06.03 1.承兑商充值USDT，根据充值记录和承兑商身份，赠送充值奖励。编写定时任务。 ##06.04 1.承兑商与第三方平台会员交易，根据承兑商等级获取相应的佣金。 2.理清用户注册码，开始做用户推荐奖金。 ##06.05 1.上午修改了第三方提现接口，重启服务一些事情 2.下午完成承兑商推荐奖金相关逻辑，检查代码等。 ##06.06 1.上午修改订单倒计时相关的接口，订单超时自动撤销单 2.下午看了多线程的相关知识。 ##06.10 1.多种支付方式相关代码修改 2.dapp_mlf_user_pay_info表增加了status、quota字段 ##06.11 1.承兑商&nbsp;-&nbsp;payChannel定时任务，查最近两天的交易记录 2.承兑商首充赠金&nbsp;-&nbsp;btc定时任务，根据爬取的充值记录、承兑商身份等，赠送首充金额 3.承兑商佣金&nbsp;-&nbsp;payChannel中第三方承兑商确认收款后，根据承兑商身份赠送佣金 4.承兑商推荐奖&nbsp;-&nbsp;payChannel中第三方承兑商确认收款后，根据承兑商身份和用户管理赠送给父级推荐奖 ##06.12 1.做一些服务器部署的事情 2.联调支付方式相关接口 ##06.13 1.修改禅道上面的bug 2.修改市商认证接口 ##06.14 1.广告表增加deal_type字段，区分手动撮合(OTC)和自动撮合 2.用户支付方式，如果一个支付方式正在使用中，不给禁用和删除，怎么判断正在使用中呢，在发布广告时是没有选择具体是哪一个支付方式的，选择的只是大概的范围，WX,ZFB,BANK三种。所以只能判断订单， 2.解决方法：在order表中增加一个order_pay_id字段，每次买家购买产生订单时，保存进去，修改pay方法 3.修改支付信息的删除和禁用接口 ##06.15 1.主要在搞广告列表显示的内容，排序要保证加载第一页时是不一样的数据，不重新加载，不影响翻页。且后面的数据排序正常，根据后台配置的那个最大页码数，来确定最大的pageNum大小、当超过后台配置的最大页码数时，返回一个空的数组。 ##06.17 1.修改卖家确认收款bug 2.修改绑定支付信息bug，重复又是删除的支付信息 3.测试第三方提现接口 4.修改市商认证的bug，当认证不通过后，重新上传会包错。update ##06.18 1.修改订单确认收款、获取广告列表方法中的一些非空判断。 2.定时查询广告，筛选出不符合要求的广告，改为已完成或者取消状态。 3.加入实名认证的使用，在发布订单、广告中添加。 ##06.19 1.修改申诉成功后的操作，后台管理IDE申诉服务 2.修改用户邀请码相关代码 3.承兑商增加密码 买方申诉成功(卖方驳回)，转账到买方对应钱包，交易成功状态 卖方申诉成功(买方驳回)，卖方增加可用余额，减少冻结余额，交易取消状态 4.OTC交易手续费扣买家还是卖家的呢？ 1.99&nbsp;49747.85&nbsp;&nbsp;253&nbsp;&nbsp;5USDT&nbsp;505CNY&nbsp; 2.33&nbsp;666440.40&nbsp;252.60&nbsp; sell&nbsp;&nbsp;33&nbsp;&nbsp;671567.40&nbsp;135.60&nbsp;&nbsp;671703.00&nbsp;&nbsp;3&nbsp;USDT&nbsp; sell&nbsp;&nbsp;33&nbsp;&nbsp;671570.40&nbsp;132.60&nbsp;&nbsp;671706.00&nbsp;&nbsp;3&nbsp;USDT&nbsp; buy&nbsp;&nbsp;99&nbsp;49727.85&nbsp;&nbsp;45030.00&nbsp;&nbsp;94757.85&nbsp;&nbsp;3&nbsp;USDT sell&nbsp;671565.40&nbsp;137.60&nbsp;&nbsp;671703.00&nbsp;&nbsp;&nbsp;33 BUY&nbsp;49727.85&nbsp;45030.00&nbsp;94757.85&nbsp;99 ##06.20 1.修改承兑商增加密码 2.user_login表中增加了承兑商密码字段 3.承兑商认证从第三方交易中获取数据 4.周五交的PPT 5.ssoIner增加服务间调用接口 6. 订单超时根据后台配置的时间来计算，返回给页面的时间接口，后台计算 7.广告列表接口修改，只显示含OTC标签的广告。发布广告时，只有承兑商才能选择标签，增加是否承兑商校验接口。 8.自己主动撤销广告不会解冻余额。 9.注册时邀请码相关逻辑修改 10.通过了市商认证就是承兑商，承兑商才可以发布自动撮合的广告 670706.40&nbsp;&nbsp;&nbsp;791.60&nbsp;&nbsp;671498.00 ##06.21 1. 发布广告，没有通过市商认证时，隐藏标签选择。页面修改 2.订单超时那儿页面功能恢复 3.实名认证那部分刷新，判断。 ##06.24 1.修改bug 2.回顾java一些基础知识，switch、流操作等 ##06.25 1.修改承兑商佣金和推荐奖金的bug 2.钱包中奖金，发布广告时怎么扣取？ ##06.26 1.测试，修改推奖金bug ##06.27 1.确认收款发生异常后，事物没有回滚 2.修改那个支付方式接口，禅道bug 购买方&nbsp;33&nbsp;：679175.55 678497.95 667.60 出售方&nbsp;111：12521.20 7381.00 5100.00 /by&nbsp;zero&nbsp;事物并未回滚&nbsp;60USDT 购买方&nbsp;33&nbsp;：679226.55 678548.95 677.60 出售方&nbsp;111：12521.20 7381.00 5040.00 第三方购买40个usdt，400， 解决加上那个东西 @TxTransaction 问题： 1.分布式事务那儿存在问题，确认收款，pay这边是发起方，btc那边是参与方，参与方出现异常，参与方不回滚。发起方回滚。加上isStart=true后，参与方、发起方都会回滚。 但是业务完成后，所有的操作都会回滚，无报错信息，SQL正常打印。目前对LCN这个还不太熟悉，后面想起来了修改。 2.财务记录显示限制，佣金显示小数精确的位数 3.推荐奖金那儿，数量为0就不保存进数据库了。 ##06.28 1. OTC目前配置为扣卖家的，OTC&nbsp;费率：0.15&nbsp; 发布了50个，卖家应该冻结&nbsp;50+50*0.15&nbsp;=&nbsp;57.5&nbsp; 发布广告前：679237.10&nbsp;&nbsp;&nbsp;685.60&nbsp;&nbsp;679922.70 发布广告后：679182.10&nbsp;&nbsp;&nbsp;740.6&nbsp;&nbsp;&nbsp;679922.70 99 94936.50 35023.00 59913.50 94936.50 34893.00 60043.50 94936.50 34843.00 60093.50 卖家减去数量，扣款减去冻结余额，手续费直接减可用余额 94914.50 34841.00 60073.50 679927.70 679187.10 740.60 ##07.01 1.注册Feign调用接口报：Caused&nbsp;by:&nbsp;java.net.SocketTimeoutException:&nbsp;Read&nbsp;timed&nbsp;out错误 2.eth报错：GC&nbsp;overhead&nbsp;limit&nbsp;exceeded 3.修改tx超时时间改为15s 4.Read&nbsp;timed&nbsp;out&nbsp;executing&nbsp;GET&nbsp;http://dapp-eth-server/inner/wallet/initWallets?userOpenId=ddb777b9-b781-4efc-a2a4-c27c924960c4这个错误和lcn事物不提交是否有关系？ ##07.03 ##07.04 1.把服务部署到50机上面 2.看Jvm、基本类型相关知识点 ##07.08 1.设置mysql SHOW&nbsp;VARIABLES&nbsp;LIKE&nbsp;'innodb_lock_wait_timeout'; SHOW&nbsp;GLOBAL&nbsp;VARIABLES&nbsp;LIKE&nbsp;'innodb_lock_wait_timeout'; SET&nbsp;innodb_lock_wait_timeout=120; SET&nbsp;GLOBAL&nbsp;innodb_lock_wait_timeout=120; SHOW&nbsp;PROCESSLIST SHOW&nbsp;PROFILE&nbsp;FOR&nbsp;QUERY&nbsp;8; SHOW&nbsp;PROFILE&nbsp;FOR&nbsp;QUERY&nbsp;1; SHOW&nbsp;VARIABLES&nbsp;LIKE&nbsp;\"%timeout%\"; SET&nbsp;GLOBAL&nbsp;wait_timeout=2000; SET&nbsp;GLOBAL&nbsp;interactive_timeout=2000; ##07.09 1.Deadlock&nbsp;found&nbsp;when&nbsp;trying&nbsp;to&nbsp;get&nbsp;lock;&nbsp;try&nbsp;restarting&nbsp;transaction，解决： https://cloud.tencent.com/developer/article/1356959 2.feign&nbsp;Read&nbsp;timed&nbsp;out&nbsp;executing&nbsp;GET 3.Lock&nbsp;wait&nbsp;timeout&nbsp;exceeded;&nbsp;try&nbsp;restarting&nbsp;transaction 4.com.mysql.jdbc.exceptions.jdbc4.MySQLTransactionRollbackException:&nbsp;Lock&nbsp;wait&nbsp;timeout&nbsp;exceeded;&nbsp;try&nbsp;restarting&nbsp;transaction 5.Communications&nbsp;link&nbsp;failure&nbsp;&nbsp; https://m635674608.iteye.com/blog/2302281 app.gswalleta.com 210.56.60.23&nbsp; ##07.12 sleep&nbsp; lazy ##07.24 1.增加了市商首次曾金配置表 CREATE&nbsp;TABLE&nbsp;`dapp_mlf_business_first`&nbsp;( &nbsp;&nbsp;`id`&nbsp;char(36)&nbsp;NOT&nbsp;NULL, &nbsp;&nbsp;`min_limit`&nbsp;decimal(20,8)&nbsp;DEFAULT&nbsp;NULL, &nbsp;&nbsp;`max_limit`&nbsp;decimal(20,8)&nbsp;DEFAULT&nbsp;NULL, &nbsp;&nbsp;`give_amount`&nbsp;decimal(20,8)&nbsp;DEFAULT&nbsp;NULL, &nbsp;&nbsp;`open_give`&nbsp;char(5)&nbsp;DEFAULT&nbsp;NULL&nbsp;COMMENT&nbsp;'是否开启首冲赠送usdt(on:开启,off:关闭)', &nbsp;&nbsp;PRIMARY&nbsp;KEY&nbsp;(`id`) )&nbsp;ENGINE=InnoDB&nbsp;DEFAULT&nbsp;CHARSET=utf8mb4 2.修改首冲奖金记录表增加字段 `status`&nbsp;tinyint(2)&nbsp;DEFAULT&nbsp;'0'&nbsp;COMMENT&nbsp;'1:未释放,2:已经释放', &nbsp;`amount`&nbsp;decimal(20,16)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;'首冲的数量', ##07.31 1.金钱包项目第一期开发收尾 2.dapp_mlf_business_charge_log&nbsp;表添加&nbsp;level_id&nbsp;字段 ##08.01 1.市商首冲配置、推荐奖金配置 2.奖金 ##08.02 1.需求评审会议 2.一键出售购买接口 ##08.03 1.28.985507&nbsp;&nbsp;471.014493 2.分析：系统内两种情况会冻结余额。 &nbsp;&nbsp;&nbsp;&nbsp;a.发布卖的广告 &nbsp;&nbsp;&nbsp;&nbsp;b.在出售大厅下单，出售大厅的下单，卖家买家都无法主动取消，等待订单超时后，取消订单。 &nbsp;&nbsp;&nbsp;&nbsp;bug：在出售大厅，卖家下单，买家不付款，超时后，卖家冻结的下单数量不会转到可用。 &nbsp;&nbsp;&nbsp;&nbsp;bug已修改 &nbsp;&nbsp;&nbsp;&nbsp;订单类型 &nbsp;&nbsp;&nbsp;&nbsp;a.BUY：用户在广告购买大厅，发起交易，买的行为，自己可以取消订单 &nbsp;&nbsp;&nbsp;&nbsp;b.SELL：用户在广告出售大厅，与买的广告单产生订单关系，双方不能主动取消订单。还会冻结用户自己的出售余额 &nbsp;&nbsp;&nbsp;&nbsp;所以 &nbsp;&nbsp;&nbsp;&nbsp;一键购买：匹配到广告后，和BUY的操作差不多 &nbsp;&nbsp;&nbsp;&nbsp;一键出售：匹配到广告后，和SELL的操作差不多，产生订单时会冻结自己的余额 ##08.04 1.一键出售接口编码、测试 2.bug修改，第三方提现，取消订单未回退冻结金额 3.对比eth代码，修改奖金一些代码 ##08.08 1.修改禅道bug 2. ##08.09 1.10级困，这样下去会出问题","link":"/2019/06/12/crawl-ydybj-1560241659811/"},{"title":"1.说一说你理解的面向对象思想？","text":"1.说一说你理解的面向对象思想？ 编写软件是为了解决某些问题，面向对象就是把这些问题中的内容抽象出来，形成一些与之对应的对象，这些对象是一些独立的、有状态的、彼此联系的个体，经过这些对象的相互作用来解决问题。面向对象的四个特征：抽象、封装、继承、多态 2.SpingBoot的单例是指什么？SpringBoot默认创建的bean是单例还是多例？为什么呢？ 单例指的是在内存中只存在一个实例对象。SpringBoot默认创建的bean是单例的。因为多例会创建更多的对象，占用更多内存。单例不会每次就去创建新的对象，控制了实例的个数利于gc回收。因此不建议在controller定义成员变量。","link":"/2019/06/12/crawl-ydybj-1560243002250/"},{"title":"angular js一$watch监控属性和对象","text":"$Watch：(监听一个model,当一个model每次改变时，都会触发第二个函数) &nbsp;$watch('watchFn',watchAction,deepWatch)watchFn：带有Angular 表达式或者函数的字符串，它会返回被监控的数据模型的当前值。watchAction:&nbsp;一个函数function(newValue,oldValue){},当watchFn 发生变化时会被调用deepWatch:默认为false,监听数组的某个元素或者对象的属性时设置为true;&nbsp;监控一个属性：&lt;!DOCTYPE&nbsp;html&gt; &lt;html&gt; &lt;head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div&nbsp;&nbsp;ng-app=&quot;myApp&quot;&nbsp;ng-controller=&quot;myCtrl&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;form&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;&nbsp;ng-model=&quot;name&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;改变次数&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt; &lt;/div&gt; &lt;script&nbsp;src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&nbsp;type=&quot;text/javascript&quot;&gt;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;app&nbsp;=&nbsp;angular.module('myApp',&nbsp;[]); &nbsp;&nbsp;&nbsp;&nbsp;app.controller('myCtrl',&nbsp;function&nbsp;($scope){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.name&nbsp;=&nbsp;'橘子'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.count&nbsp;=&nbsp;0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.$watch('name',&nbsp;function&nbsp;(newValue,&nbsp;oldValue)&nbsp;{ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($scope.count&nbsp;&gt;5){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.name&nbsp;=&nbsp;'苹果'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}); &nbsp;&nbsp;&nbsp;&nbsp;});&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;监控一个对象（deepWidth为true）&lt;!DOCTYPE&nbsp;html&gt; &lt;html&gt; &lt;head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;charset=&quot;utf-8&quot;/&gt; &lt;/head&gt; &lt;body&gt; &lt;div&nbsp;&nbsp;ng-app=&quot;myApp&quot;&nbsp;ng-controller=&quot;myCtrl&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;form&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;class=&quot;form-group&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;input&nbsp;&nbsp;ng-model=&quot;Data.name&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;p&gt;改变次数&lt;/p&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/div&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/form&gt; &lt;/div&gt; &lt;script&nbsp;src=&quot;http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js&quot;&gt;&lt;/script&gt; &lt;script&nbsp;type=&quot;text/javascript&quot;&gt;&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;app&nbsp;=&nbsp;angular.module('myApp',&nbsp;[]); &nbsp;&nbsp;&nbsp;&nbsp;app.controller('myCtrl',&nbsp;function&nbsp;($scope){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.Data&nbsp;=&nbsp;{&nbsp;name:&nbsp;'橘子'&nbsp;}; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.count&nbsp;=&nbsp;0; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.$watch('Data',&nbsp;function&nbsp;(newValue,&nbsp;oldValue)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(newValue&nbsp;==&nbsp;oldValue)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.count++;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if($scope.count&nbsp;&gt;5){ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;$scope.Data.name&nbsp;=&nbsp;'苹果'; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},&nbsp;true); &nbsp;&nbsp;&nbsp;&nbsp;});&lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","link":"/2017/12/09/angular/"},{"title":"账号密码","text":"账号密码 1.禅道&nbsp; http://120.79.243.120:6699/zentao/project-view-1.html &nbsp;账号：herui&nbsp;密码：herui2019 2.本地sw地址 http://192.168.105.101:10503/swagger-ui.html#!/ 3.服务器上面启动vue项目 &nbsp;cd&nbsp;blog_page &nbsp;运行在本地&nbsp;&nbsp;npm&nbsp;run&nbsp;dev &nbsp;打包&nbsp;npm&nbsp;run&nbsp;build 4.linux 4.1&nbsp;防火墙开放某端口 &nbsp;vi&nbsp;etc/sysconfig/iptables&nbsp;增加一行 &nbsp;service&nbsp;iptables&nbsp;restart iptables&nbsp;-L&nbsp;-n 4.2查看端口占用情况 netstat&nbsp;-tunlp&nbsp;|&nbsp; grep &nbsp; 10001 lsof&nbsp;-i:10001 5.vue项目部署到nginx https://blog.csdn.net/weixin_36869329/article/details/81910456 5.1&nbsp;打包vue项目 5.2&nbsp;在nginx.conf中转发到dist目录 5.3&nbsp;重启nginx，访问 6. http://localhost:7998/index2.html http://192.168.105.101 :7998/index2.html 需要我帮你百度吗&nbsp; https://ffis.me/baidu/?devdependencies devDependencies&nbsp;&nbsp;里面的插件只用于开发环境，不用于生产环境，而&nbsp;dependencies&nbsp;&nbsp;是需要发布到生产环境的。 7.好熟悉呀&nbsp;这个东西不是我在学校花了一个多月弄出来的吗？原来只是一个模板，没想到再次相遇。 https://blog.seoui.com &nbsp;wordpress 8. ssh: 192.200.119.130 root/pDUFUTUvaVWpBAmthWXf","link":"/2019/06/12/crawl-ydybj-1560251581144/"},{"title":"Docker安装Nginx","text":"Docker安装Nginx并设置代理 1.&nbsp;下载最新的nginx的docker&nbsp;image $&nbsp;docker&nbsp;pull&nbsp;nginx:latest 2.&nbsp;启动nginx容器 docker&nbsp;run&nbsp;-d&nbsp;--name&nbsp;nginx&nbsp;-p&nbsp;80:80&nbsp; --net&nbsp;host &nbsp;-v&nbsp; /docker/nginx/conf/nginx.conf :/etc/nginx/nginx.conf&nbsp;-v&nbsp; /docker/nginx/log :/var/log/nginx&nbsp;-v&nbsp; /docker/nginx/html :/usr/share/nginx/html&nbsp;-v&nbsp; /docker/nginx/conf.d/default.conf :/etc/nginx/conf.d/default.conf&nbsp;nginx 注意！注意！注意！： 1、 此是重中之重： &nbsp;&nbsp;&nbsp;&nbsp; 启动nginx容器时&nbsp;一定要加&nbsp; --net&nbsp;host&nbsp;参数&nbsp;（ 解释：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。 ） &nbsp;&nbsp;&nbsp;&nbsp; 个人理解：如果不加此参数，nginx相当于是代理nginx镜像的IP及端口，因为nginx镜像也是独立的虚机，贴上此图，便于理解 2、首先创建这些文件夹及文件(红色标记) 3、nginx.conf内容如下 4、default.conf内容如下 启动成功之后&nbsp;查看运行的镜像 &nbsp;&nbsp;&nbsp;&nbsp;会发现，--net&nbsp;host模式运行的镜像是没有端口映射的，因为用的就是宿主机的IP和端口 以后添加端口代理时，直接在红色标记框下添加内容，然后重启nginx：docker&nbsp;restart&nbsp;[nginx容器ID]","link":"/2019/07/20/crawl-ydybj-1563507281978/"},{"title":"遇到错误的记录","text":"遇到错误的记录 1. [JAVA]&nbsp;Map中的key，用 containsKey(key)方法时，key的类型也要一致。--07-29 2.[JAVA]&nbsp;MyBatis中查询结果映射到实体类为null，有查询结果。对应的实体类按照驼峰式命名，不然找不到。 可以把下面这个关掉 mybatis : &nbsp;&nbsp; configuration : &nbsp;&nbsp;&nbsp;&nbsp; map-underscore-to-camel-case :&nbsp;true 或者使用resultMap映射 3.[JS]&nbsp;关于for&nbsp;(var&nbsp;index&nbsp;in&nbsp;items)和for&nbsp;(var&nbsp;i&nbsp;=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;items.length;&nbsp;i++) 前者循环的是属性，后者循环的才是数组。若项目中对数组属性进行了扩展，那切记不能使用前者，否则在循环数组时扩展的函数体也会被当做数据返回。 4.[JAVA]&nbsp;@Autowired(required=false)：表示忽略当前要注入的bean，如果有直接注入，没有跳过，不会报错。 5.[JAVA]&nbsp;从Java&nbsp;EE5规范开始，Servlet增加了两个影响Servlet生命周期的注解（Annotation）：@PostConstruct和@PreConstruct。这两个注解被用来修饰一个非静态的void()方法.而且这个方法不能有抛出异常声明。 5.1.@PostConstruct说明:被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的init()方法。被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。 5.2.@PreConstruct说明:被@PreConstruct修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreConstruct修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。（详见下面的程序实践） 6.[JAVA]&nbsp;@ConditionalOnxxx注解 @ConditionalOnBean：当给定的在bean存在时,则实例化当前Bean @ConditionalOnMissingBean：当给定的在bean不存在时,则实例化当前Bean @ConditionalOnClass：当给定的类名在类路径上存在，则实例化当前Bean @ConditionalOnMissingClass：当给定的类名在类路径上不存在，则实例化当前Bean @ConditionalOnProperty(prefix&nbsp;=&nbsp;\"rest\",&nbsp;name&nbsp;=&nbsp;\"auth-open\",&nbsp;havingValue&nbsp;=&nbsp;\"true\",&nbsp;matchIfMissing&nbsp;=&nbsp;true) prefix&nbsp;application.properties配置的前缀 name&nbsp;属性是从application.properties配置文件中读取属性值 havingValue&nbsp;配置读取的属性值跟havingValue做比较，如果一样则返回true;否则返回false。 如果返回值为false，则该configuration不生效；为true则生效 matchIfMissing&nbsp;=&nbsp;true表示如果没有在application.properties设置该属性，则默认为条件符合 是否启动jwt的的配置，如果application.properties配置中没有设置就启动jwt，如果设置了true就启动，如果false就关闭 application.properties&nbsp;配置如下 rest: &nbsp;&nbsp;auth-open:&nbsp;true&nbsp;#jwt鉴权机制是否开启(true或者false)","link":"/2019/08/02/crawl-ydybj-1564654768707/"},{"title":"在有道云笔记上面写的东西转移到博客系统上","text":"平时工作时会把一些遇到的问题记录在有道云笔记上面，昨天突然想，怎么把有道云笔记上面记得内容迁移到自己的博客系统中。之前有写过一些爬虫，所以很快有了思路。 一、获取链接 在有道云笔记客户端获取笔记内容的分享链接，在浏览器打开它，F12查看源码会发现页面内容并没有出现在页面中。这说明页面内容需要从接口中获取。点开NetWork查看异步请求记录 嗯，很快就找到了这个请求接口，传了三个参数，经过测试，这三个参数传不传都不影响内容获取。主要是路径中的参数，它是一个唯一的id，传它就可以了。 二、接口编写 在系统中需要提供一个接收url参数的接口，用来处理页面内容和保存内容入库，接口中的主要代码 其中，图片我转存到了七牛云，如果不转存也可以。但是chrome会显示https警告，因为站点是https的原因。 页面内容处理成功后，就是保存自己系统中就可以了。如果后续需要更新，可以把这个id也保存进去，下次更新的时候使用。 笔记里面代码内容部分，是不会显示出样式了，后续考虑再去处理这点。 目前接口没有限制用户身份，这个后面也需要简单改一下。 其他，还没想到怎么让这个操作自动化，自动获取分享的链接，调用接口的操作。后续如果想到会补充上去。","link":"/2019/06/13/crawl-ydybj-1560314054272/"},{"title":"Dubbo初始","text":"Dubbo作用 以前，如果要使用别人的服务，应该做的是直接调用别人的实现函数，这样就会有一个问题，会把自己的实现源码暴露给别人，而现在的大多数时候，我们并不想这样做，我们只想给你用这个功能，却不想告诉你它是怎么实现的。这个时候，就需要用到dubbo和接口了。 只提供给消费者接口，这样消费者就无法看到具体的实现，但是因为你接口包含了所有的业务功能，所以可以直接知道这个接口有什么用。但是一个接口要真正用起来，肯定是要实现的，这个时候，dubbo就派上了用场。 服务提供者提供接口，并且提供接口的实现，这个服务通过dubbo注册到zookeep服务器上。然后消费者要用某个服务的时候，就去zookeep上订阅该服务。这样，我们只需要使用接口，然后通过spring getbean，就可以让这个接口实例化，拿来使用。同时因为消费者只能得到接口，而无法看到接口的实现，也保证了服务者的安全。 弄了差不多几个小时，总算弄好了，Springboot+Dubbo+zk+maven整合。 也把dubbo-admin弄好了。 这两个starter，一开始搞错了。 &lt;!-- 第一种starter --&gt; &lt;dependency&gt; &nbsp; &nbsp; &lt;groupId&gt;io.dubbo.springboot&lt;/groupId&gt; &nbsp; &nbsp; &lt;artifactId&gt;spring-boot-starter-dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 第二种dubbo的starter --&gt; &lt;dependency&gt; &nbsp; &nbsp; &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt; &nbsp; &nbsp; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; 这两种在properties文件中属性定义的名称不一样。我用的第二种，包扫描好像不行。启动类加了@EnableDubbo注解就行了。 我是部署在本地的，maven父子项目结构。改天部署到服务器上去，另外有把这个博客系统全部重构一边的想法，虽然想在也没时间做，以前有时间也没做。。。 dubbo-admin:localhost:9000,root,root 1、启动zookeeper 2、启动启动生产者、消费者 3、消费服务 4、admin页面查看信息 &nbsp; &nbsp; 电脑也不卡了，之前记得搞了一次电脑内存了设置，为了C盘空间更大。现在就是这个原因导致我电脑一直卡卡卡，刚才idea跑了两个项目，起了zk和d-admin，开了chrome浏览器，电脑就崩了几次。设置回来后，电脑用起来舒服多了。 找工作，有点儿着急心里。 不过学习起来，真的很舒服呀。内心会很轻松，没有任何负担。 想起未来，是不是该努力点呢。一直玩儿的话，内心也会越来越难受。 就这样吧。争取早点找到工作。 &nbsp;","link":"/2019/03/07/dubbo-simple-demo/"},{"title":"刚才一不小心，导入一个表，结果数据库全部没了","text":"刚才一不小心，导入一个表，结果数据库全部没了，顿时懵逼， 虽然博客不多，也难得写呀。。。本来想着不会的，侥幸心理。。哎","link":"/2017/12/05/database-clear-all/"},{"title":"ElementUI折叠菜单使用笔记","text":"左边导航栏的宽度不要在外面的div定义，折叠后ul就不会有宽度了。","link":"/2018/01/27/elementui-left-nav-problem/"},{"title":"很久没有学习了，越来越懒了","text":"1.tomcat最近这一段时间老是自动关闭。 2.Myeclipse用起来越来越烦，还是再用10.7版本。3.说好的评论系统也没做。4.现在开始在做毕业设计，SSH架构，以前学习的忘记很多了。5.工作中遇到的问题和解决方法没有及时记录到博客中。6.工作了之后，觉得这个博客系统也应该来一个大的改造。是不是很懒了？游戏好玩儿呀。。","link":"/2018/03/18/feeling-lazier-and-lazier/"},{"title":"ElasticSearch安装篇","text":"一、介绍ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个基于RESTful web接口的分布式全文搜索引擎。ElasticSearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。ElasticSearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。根据DB-Engines的排名显示，ElasticSearch是最受欢迎的企业搜索引擎，其次是Apache Solr（也是基Lucene）。 二、开始安装选择好es的版本下载其压缩包。中文社区下载中心，我这里下载的是elasticsearch-6.6.2.tar.gz版本和公司里面使用的一样。创建一个elasticSearch用户，把es文件加上改权限 1chown -R elasticsearchs:elasticsearch /home/elasticsearch-6.6.2 下载好后上传到服务器，解压目录如下： 2.1 es的目录介绍bin：可执行文件在里面，运行es的命令就在这个里面，包含了一些脚本文件等config：配置文件目录JDK：java环境lib：依赖的jar，类库logs：日志文件modules：es相关的模块plugins：可以自己开发的插件data：这个目录没有，自己新建一下，后面要用 -&gt; mkdir data，这个作为索引目录 2.2 配置修改进入config目录，编辑elasticsearch.yml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495# NOTE: Elasticsearch comes with reasonable defaults for most settings.# Before you set out to tweak and tune the configuration, make sure you# understand what are you trying to accomplish and the consequences.## The primary way of configuring a node is via this file. This template lists# the most important settings you may want to configure for a production cluster.## Please consult the documentation for further information on configuration options:# https://www.elastic.co/guide/en/elasticsearch/reference/index.html## ---------------------------------- Cluster -----------------------------------## Use a descriptive name for your cluster:#cluster.name: hr2812## ------------------------------------ Node ------------------------------------## Use a descriptive name for the node:#node.name: node-1node.master: true## Add custom attributes to the node:##node.attr.rack: r1## ----------------------------------- Paths ------------------------------------## Path to directory where to store the data (separate multiple locations by comma):##path.data: /path/to/data## Path to log files:##path.logs: /path/to/logs## ----------------------------------- Memory -----------------------------------## Lock the memory on startup:##bootstrap.memory_lock: true## Make sure that the heap size is set to about half the memory available# on the system and that the owner of the process is allowed to use this# limit.## Elasticsearch performs poorly when the system is swapping the memory.## ---------------------------------- Network -----------------------------------## Set the bind address to a specific IP (IPv4 or IPv6):##network.host: 192.168.0.1#network.host: 193.112.14.78network.host: 0.0.0.0#network.publish_host: 0.0.0.0## Set a custom port for HTTP:#http.port: 9200# 允许跨域http.cors.enabled: truehttp.cors.allow-origin: \"*\"## For more information, consult the network module documentation.## --------------------------------- Discovery ----------------------------------## Pass an initial list of hosts to perform discovery when new node is started:# The default list of hosts is [\"127.0.0.1\", \"[::1]\"]##discovery.zen.ping.unicast.hosts: [\"host1\", \"host2\"]#discovery.zen.ping.unicast.hosts: [\"193.112.14.78:9300\"]## Prevent the \"split brain\" by configuring the majority of nodes (total number of master-eligible nodes / 2 + 1):##discovery.zen.minimum_master_nodes: ## For more information, consult the zen discovery module documentation.## ---------------------------------- Gateway -----------------------------------## Block initial recovery after a full cluster restart until N nodes are started:##gateway.recover_after_nodes: 3## For more information, consult the gateway module documentation.## ---------------------------------- Various -----------------------------------## Require explicit names when deleting indices:##action.destructive_requires_name: true 修改jvm.options 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122## JVM configuration################################################################## IMPORTANT: JVM heap size#################################################################### You should always set the min and max JVM heap## size to the same value. For example, to set## the heap to 4 GB, set:#### -Xms4g## -Xmx4g#### See https://www.elastic.co/guide/en/elasticsearch/reference/current/heap-size.html## for more information################################################################### Xms represents the initial size of total heap space# Xmx represents the maximum size of total heap space-Xms128m-Xmx128m################################################################## Expert settings#################################################################### All settings below this section are considered## expert settings. Don't tamper with them unless## you understand what you are doing#################################################################### GC configuration-XX:+UseConcMarkSweepGC-XX:CMSInitiatingOccupancyFraction=75-XX:+UseCMSInitiatingOccupancyOnly## G1GC Configuration# NOTE: G1GC is only supported on JDK version 10 or later.# To use G1GC uncomment the lines below.# 10-:-XX:-UseConcMarkSweepGC# 10-:-XX:-UseCMSInitiatingOccupancyOnly# 10-:-XX:+UseG1GC# 10-:-XX:InitiatingHeapOccupancyPercent=75## DNS cache policy# cache ttl in seconds for positive DNS lookups noting that this overrides the# JDK security property networkaddress.cache.ttl; set to -1 to cache forever-Des.networkaddress.cache.ttl=60# cache ttl in seconds for negative DNS lookups noting that this overrides the# JDK security property networkaddress.cache.negative ttl; set to -1 to cache# forever-Des.networkaddress.cache.negative.ttl=10## optimizations# pre-touch memory pages used by the JVM during initialization-XX:+AlwaysPreTouch## basic# explicitly set the stack size-Xss1m# set to headless, just in case-Djava.awt.headless=true# ensure UTF-8 encoding by default (e.g. filenames)-Dfile.encoding=UTF-8# use our provided JNA always versus the system one-Djna.nosys=true# turn off a JDK optimization that throws away stack traces for common# exceptions because stack traces are important for debugging-XX:-OmitStackTraceInFastThrow# flags to configure Netty-Dio.netty.noUnsafe=true-Dio.netty.noKeySetOptimization=true-Dio.netty.recycler.maxCapacityPerThread=0# log4j 2-Dlog4j.shutdownHookEnabled=false-Dlog4j2.disable.jmx=true-Djava.io.tmpdir=${ES_TMPDIR}## heap dumps# generate a heap dump when an allocation from the Java heap fails# heap dumps are created in the working directory of the JVM-XX:+HeapDumpOnOutOfMemoryError# specify an alternative path for heap dumps; ensure the directory exists and# has sufficient space-XX:HeapDumpPath=data# specify an alternative path for JVM fatal error logs-XX:ErrorFile=logs/hs_err_pid%p.log## JDK 8 GC logging8:-XX:+PrintGCDetails8:-XX:+PrintGCDateStamps8:-XX:+PrintTenuringDistribution8:-XX:+PrintGCApplicationStoppedTime8:-Xloggc:logs/gc.log8:-XX:+UseGCLogFileRotation8:-XX:NumberOfGCLogFiles=328:-XX:GCLogFileSize=64m# JDK 9+ GC logging9-:-Xlog:gc*,gc+age=trace,safepoint:file=logs/gc.log:utctime,pid,tags:filecount=32,filesize=64m# due to internationalization enhancements in JDK 9 Elasticsearch need to set the provider to COMPAT otherwise# time/date parsing will break in an incompatible way for some date patterns and locals9-:-Djava.locale.providers=COMPAT# temporary workaround for C2 bug with JDK 10 on hardware with AVX-51210-:-XX:UseAVX=2 2.3 启动进入/bin目录，执行。/elasticsearch -d 2.4 验证启动结果123456789101112131415161718[root@yasuo config]# curl localhost:9200{ \"name\" : \"node-1\", \"cluster_name\" : \"hr2812\", \"cluster_uuid\" : \"5NUf3QFJRTi7kWo1aXAyRg\", \"version\" : { \"number\" : \"6.6.2\", \"build_flavor\" : \"default\", \"build_type\" : \"tar\", \"build_hash\" : \"3bd3e59\", \"build_date\" : \"2019-03-06T15:16:26.864148Z\", \"build_snapshot\" : false, \"lucene_version\" : \"7.6.0\", \"minimum_wire_compatibility_version\" : \"5.6.0\", \"minimum_index_compatibility_version\" : \"5.0.0\" }, \"tagline\" : \"You Know, for Search\"} 2.5 停止1pa -aux|grep java 杀掉相关进程号。","link":"/2020/09/25/elasticsearch-environment-on-linux/"},{"title":"睡觉、最近好多事要做。。","text":"最近好多事要做。 工作中的问题很多，需要解决。毕业设计开题报告快交了。还有这个博客系统，越来觉得很多不好的地方。。。睡觉、睡觉、、、","link":"/2017/12/27/feel-down/"},{"title":"FreeMarker判断对象为空","text":"由于以前没有用过。。 所以，老大叫我们跟着他的模板写。。有一个地方，是这样的：&lt;#if&nbsp;!actActivity??&gt; &nbsp;var&nbsp;activity&nbsp;=${actActivity}; &lt;#else&gt; &nbsp;... &lt;/#if&gt;因为这个地方，我搞了很久。。正确的判断为空：if和??使用&lt;#if&nbsp;actActivity??&gt; &nbsp;var&nbsp;activity&nbsp;=${actActivity}; &lt;#else&gt; &nbsp;... &lt;/#if&gt;$和！使用${activity.site!'0'}如果site为null，赋值为0","link":"/2018/01/11/freemarker-judgment-object-is-empty/"},{"title":"看电视","text":"昨晚看剧到四点多，刚才起来。待会儿来上传图片 &nbsp;","link":"/2019/06/24/film-animation-TV-europe/"},{"title":"Feign服务间调用超时问题(结合项目中的TxLCNf框架)","text":"Feign服务间调用超时问题(结合项目中的TxLCNf框架)1.消费方超时 这里是指，服务方等待消费方返回事务的消息，等待超时(结合txlcn框架来说)；在txlcn分布式事务框架中，消费方调用服务方的接口，调用成功后，睡10s，在提交事务；此时在服务方会报超时的错误信息，该错误和txlcn的配置项： tm.compensate.maxWaitTime=xxxx 有关 正常调用的日志信息 1234567891011121314X-Requested-Inner&gt;&gt;&gt;bi@123jiao!678suobtc测试调用...15:00:44.244 [http-nio-18301-exec-1] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Preparing: update dapp_u_user_info set modify_time=now(),email=? where user_id=? 15:00:44.245 [http-nio-18301-exec-1] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Parameters: demo11(String), a297a261-4f6e-49bc-9a94-a9785f58bd9c(String)15:00:44.260 [http-nio-18301-exec-1] DEBUG c.b.s.b.m.B.test - [debug,159] - &lt;== Updates: 115:00:44.271 [sender-thread-6] INFO c.c.t.f.u.SocketManager - [sleepSend,85] - send-msg-&gt;{&quot;a&quot;:&quot;atg&quot;,&quot;k&quot;:&quot;zkZcP6tG&quot;,&quot;p&quot;:{&quot;s&quot;:0,&quot;t&quot;:&quot;15ZfwYcQ&quot;,&quot;ms&quot;:&quot;public void com.blockchain.server.btc.service.impl.BtcWalletTransferServiceImpl.test(java.lang.String,java.lang.String)&quot;,&quot;g&quot;:&quot;4M3czL7a&quot;}} maxOutTime : 500015:00:44.323 [Thread-109] INFO c.c.t.d.r.LCNDBConnection - [transaction,160] - transaction is wait for TxManager notify, groupId 4M3czL7a15:00:44.323 [receiver-thread-32] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,84] - receive response -&gt; {&quot;d&quot;:&quot;{\\&quot;st\\&quot;:1571209243109,\\&quot;r\\&quot;:0,\\&quot;s\\&quot;:0,\\&quot;nt\\&quot;:1571209244322,\\&quot;g\\&quot;:\\&quot;4M3czL7a\\&quot;,\\&quot;i\\&quot;:0,\\&quot;o\\&quot;:0}&quot;,&quot;k&quot;:&quot;zkZcP6tG&quot;}15:00:44.326 [http-nio-18301-exec-1] INFO c.c.t.s.l.ServerListener - [onApplicationEvent,27] - onApplicationEvent -&gt; onApplicationEvent. 15:00:44.326 [TxInit-thread] INFO c.c.t.l.s.i.InitServiceImpl - [start,24] - socket-start..15:00:44.452 [receiver-thread-33] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,77] - receive cmd -&gt; {&quot;a&quot;:&quot;t&quot;,&quot;c&quot;:1,&quot;t&quot;:&quot;15ZfwYcQ&quot;,&quot;k&quot;:&quot;DYsnIZt8&quot;}15:00:44.452 [receiver-thread-33] INFO c.c.t.c.s.i.ActionTServiceImpl - [execute,35] - accept notify data -&gt;{&quot;a&quot;:&quot;t&quot;,&quot;c&quot;:1,&quot;t&quot;:&quot;15ZfwYcQ&quot;,&quot;k&quot;:&quot;DYsnIZt8&quot;}15:00:44.484 [Thread-109] INFO c.c.t.d.r.LCNDBConnection - [transaction,176] - lcn transaction over, res -&gt; groupId:4M3czL7a and state is commit 超时时服务方打印的信息(调用方线程睡了10s) 12345678910111213141516171819btc测试调用...15:07:24.676 [http-nio-18301-exec-4] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Preparing: update dapp_u_user_info set modify_time=now(),email=? where user_id=? 15:07:24.677 [http-nio-18301-exec-4] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Parameters: demo11(String), a297a261-4f6e-49bc-9a94-a9785f58bd9c(String)15:07:24.680 [http-nio-18301-exec-4] DEBUG c.b.s.b.m.B.test - [debug,159] - &lt;== Updates: 1 maxOutTime : 500015:07:24.713 [sender-thread-7] INFO c.c.t.f.u.SocketManager - [sleepSend,85] - send-msg-&gt;{&quot;a&quot;:&quot;atg&quot;,&quot;k&quot;:&quot;i2eAfrw4&quot;,&quot;p&quot;:{&quot;s&quot;:0,&quot;t&quot;:&quot;k7Sa0UmX&quot;,&quot;ms&quot;:&quot;public void com.blockchain.server.btc.service.impl.BtcWalletTransferServiceImpl.test(java.lang.String,java.lang.String)&quot;,&quot;g&quot;:&quot;HkDIt5SU&quot;}}15:07:24.714 [Thread-127] INFO c.c.t.d.r.LCNDBConnection - [transaction,160] - transaction is wait for TxManager notify, groupId HkDIt5SU15:07:24.726 [receiver-thread-61] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,84] - receive response -&gt; {&quot;d&quot;:&quot;{\\&quot;st\\&quot;:1571209643257,\\&quot;r\\&quot;:0,\\&quot;s\\&quot;:0,\\&quot;nt\\&quot;:1571209644723,\\&quot;g\\&quot;:\\&quot;HkDIt5SU\\&quot;,\\&quot;i\\&quot;:0,\\&quot;o\\&quot;:0}&quot;,&quot;k&quot;:&quot;i2eAfrw4&quot;}15:07:24.749 [http-nio-18301-exec-4] INFO c.c.t.s.l.ServerListener - [onApplicationEvent,27] - onApplicationEvent -&gt; onApplicationEvent. 15:07:24.754 [TxInit-thread] INFO c.c.t.l.s.i.InitServiceImpl - [start,24] - socket-start..auto execute ,groupId:HkDIt5SU15:07:29.713 [sender-thread-8] INFO c.c.t.f.u.SocketManager - [sleepSend,85] - send-msg-&gt;{&quot;a&quot;:&quot;ckg&quot;,&quot;k&quot;:&quot;GEC41B1Q&quot;,&quot;p&quot;:{&quot;t&quot;:&quot;datasource_k7Sa0UmX&quot;,&quot;g&quot;:&quot;HkDIt5SU&quot;}}15:07:29.718 [receiver-thread-62] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,84] - receive response -&gt; {&quot;d&quot;:&quot;0&quot;,&quot;k&quot;:&quot;GEC41B1Q&quot;}15:07:29.740 [Thread-127] INFO c.c.t.d.r.LCNDBConnection - [transaction,176] - lcn transaction over, res -&gt; groupId:HkDIt5SU and state is rollback15:07:34.783 [receiver-thread-63] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,77] - receive cmd -&gt; {&quot;a&quot;:&quot;t&quot;,&quot;c&quot;:0,&quot;t&quot;:&quot;k7Sa0UmX&quot;,&quot;k&quot;:&quot;e0JwOnHP&quot;}15:07:34.784 [receiver-thread-63] INFO c.c.t.c.s.i.ActionTServiceImpl - [execute,35] - accept notify data -&gt;{&quot;a&quot;:&quot;t&quot;,&quot;c&quot;:0,&quot;t&quot;:&quot;k7Sa0UmX&quot;,&quot;k&quot;:&quot;e0JwOnHP&quot;}15:07:34.784 [receiver-thread-63] INFO c.c.t.c.s.i.ActionTServiceImpl - [execute,66] - accept notify response res -&gt;015:07:34.785 [receiver-thread-63] INFO c.c.t.c.s.i.TransactionControlServiceImpl - [notifyTransactionMsg,50] - send notify data -&gt;{&quot;p&quot;:{&quot;d&quot;:&quot;0&quot;},&quot;a&quot;:&quot;t&quot;,&quot;k&quot;:&quot;e0JwOnHP&quot;}15:07:34.787 [receiver-thread-64] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,84] - receive response -&gt; {&quot;d&quot;:&quot;&quot;,&quot;k&quot;:&quot;e0JwOnHP&quot;} 上面可以看到15:07:24开始执行，15:07:29 [Thread-127] INFO c.c.t.d.r.LCNDBConnection - [transaction,176] - lcn transaction over, res -&gt; groupId:HkDIt5SU and state is rollback事务回滚，中间相差5s，这应该就是超时时间 增加超时时间，增加到15s 1234567891011121314151617181920#指的是模块执行自动超时的最大时间，该最大时间若过段会导致事务机制异常，该时间必须要模块之间通讯的最大超过时间。#例如，若模块A与模块B，请求超时的最大时间是5秒，则建议改时间至少大于5秒。tm.compensate.maxWaitTime=5000修改为tm.compensate.maxWaitTime=15000这是打印出的日志就是：btc测试调用...15:23:04.886 [http-nio-18301-exec-1] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Preparing: update dapp_u_user_info set modify_time=now(),email=? where user_id=? 15:23:04.912 [http-nio-18301-exec-1] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Parameters: demo11(String), a297a261-4f6e-49bc-9a94-a9785f58bd9c(String)15:23:04.915 [http-nio-18301-exec-1] DEBUG c.b.s.b.m.B.test - [debug,159] - &lt;== Updates: 1 maxOutTime : 1500015:23:04.920 [sender-thread-2] INFO c.c.t.f.u.SocketManager - [sleepSend,85] - send-msg-&gt;{&quot;a&quot;:&quot;atg&quot;,&quot;k&quot;:&quot;iOAoPJY7&quot;,&quot;p&quot;:{&quot;s&quot;:0,&quot;t&quot;:&quot;M7jajJVi&quot;,&quot;ms&quot;:&quot;public void com.blockchain.server.btc.service.impl.BtcWalletTransferServiceImpl.test(java.lang.String,java.lang.String)&quot;,&quot;g&quot;:&quot;TabNLFcw&quot;}}15:23:04.920 [Thread-86] INFO c.c.t.d.r.LCNDBConnection - [transaction,160] - transaction is wait for TxManager notify, groupId TabNLFcw15:23:04.926 [receiver-thread-5] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,84] - receive response -&gt; {&quot;d&quot;:&quot;{\\&quot;st\\&quot;:1571210583545,\\&quot;r\\&quot;:0,\\&quot;s\\&quot;:0,\\&quot;nt\\&quot;:1571210584925,\\&quot;g\\&quot;:\\&quot;TabNLFcw\\&quot;,\\&quot;i\\&quot;:0,\\&quot;o\\&quot;:0}&quot;,&quot;k&quot;:&quot;iOAoPJY7&quot;}15:23:04.959 [http-nio-18301-exec-1] INFO c.c.t.s.l.ServerListener - [onApplicationEvent,27] - onApplicationEvent -&gt; onApplicationEvent. 15:23:04.960 [TxInit-thread] INFO c.c.t.l.s.i.InitServiceImpl - [start,24] - socket-start..15:23:14.998 [receiver-thread-6] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,77] - receive cmd -&gt; {&quot;a&quot;:&quot;t&quot;,&quot;c&quot;:1,&quot;t&quot;:&quot;M7jajJVi&quot;,&quot;k&quot;:&quot;IdasBdx2&quot;}15:23:14.998 [receiver-thread-6] INFO c.c.t.c.s.i.ActionTServiceImpl - [execute,35] - accept notify data -&gt;{&quot;a&quot;:&quot;t&quot;,&quot;c&quot;:1,&quot;t&quot;:&quot;M7jajJVi&quot;,&quot;k&quot;:&quot;IdasBdx2&quot;}15:23:15.027 [Thread-86] INFO c.c.t.d.r.LCNDBConnection - [transaction,176] - lcn transaction over, res -&gt; groupId:TabNLFcw and state is commit 从上面的日志信息可知程序在15:23:04秒开始执行，在15:23:15秒执行成功，并成功提交事务，main-Thread睡了10秒模拟超时，修改tx配置文件，最后成功提交事务。 ####2.服务方超时 服务方超时：这里是指消费方调用服务方接口超时，和feign的配置有关 在服务方方法中睡30s,结果消费方在3s后报超时的错误，返回500到前端；服务方在等待30s后，出现如下面错误： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111btc测试调用...15:53:50.921 [DiscoveryClient-CacheRefreshExecutor-0] INFO c.c.t.s.l.ServerListener - [onApplicationEvent,27] - onApplicationEvent -&gt; onApplicationEvent. 15:53:50.922 [TxInit-thread] INFO c.c.t.l.s.i.InitServiceImpl - [start,24] - socket-start..15:53:57.872 [http-nio-18301-exec-4] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Preparing: update dapp_u_user_info set modify_time=now(),email=? where user_id=? 15:53:57.873 [http-nio-18301-exec-4] DEBUG c.b.s.b.m.B.test - [debug,159] - ==&gt; Parameters: demo12(String), a297a261-4f6e-49bc-9a94-a9785f58bd9c(String)15:53:57.875 [http-nio-18301-exec-4] DEBUG c.b.s.b.m.B.test - [debug,159] - &lt;== Updates: 1 maxOutTime : 1500015:53:57.875 [Thread-123] INFO c.c.t.d.r.LCNDBConnection - [transaction,160] - transaction is wait for TxManager notify, groupId kcxZJOnG15:53:57.876 [sender-thread-5] INFO c.c.t.f.u.SocketManager - [sleepSend,85] - send-msg-&gt;{&quot;a&quot;:&quot;atg&quot;,&quot;k&quot;:&quot;sMitKicP&quot;,&quot;p&quot;:{&quot;s&quot;:0,&quot;t&quot;:&quot;Z0N0azcs&quot;,&quot;ms&quot;:&quot;public void com.blockchain.server.btc.service.impl.BtcWalletTransferServiceImpl.test(java.lang.String,java.lang.String)&quot;,&quot;g&quot;:&quot;kcxZJOnG&quot;}}15:53:57.878 [receiver-thread-55] INFO c.c.t.n.s.i.NettyControlServiceImpl - [executeService,84] - receive response -&gt; {&quot;d&quot;:&quot;&quot;,&quot;k&quot;:&quot;sMitKicP&quot;}15:53:57.879 [http-nio-18301-exec-4] WARN c.c.t.a.s.i.TxRunningTransactionServerImpl - [execute,105] - wake the waitTask: true15:53:57.879 [http-nio-18301-exec-4] ERROR c.b.s.b.c.GlobalExceptionHandle - [handleUnknownException,60] - Wed Oct 16 15:53:57 CST 2019系统抛出异常，异常是：java.lang.reflect.UndeclaredThrowableException，异常信息是：null15:53:57.879 [http-nio-18301-exec-4] ERROR c.b.s.b.c.GlobalExceptionHandle - [handleUnknownException,64] - 请求路径：http://SKY-20180728BUM:18301/inner/walletTx/test15:53:57.880 [http-nio-18301-exec-4] ERROR c.b.s.b.c.GlobalExceptionHandle - [handleUnknownException,67] - 响应头：nulljava.lang.reflect.UndeclaredThrowableException at com.blockchain.server.btc.service.impl.BtcWalletTransferServiceImpl$$EnhancerBySpringCGLIB$$3b11ec8b.test(&lt;generated&gt;) at com.blockchain.server.btc.inner.BtcWalletTransferInner.test(BtcWalletTransferInner.java:56) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:209) at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:136) at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:102) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:877) at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:783) at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:991) at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:925) at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:974) at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:877) at javax.servlet.http.HttpServlet.service(HttpServlet.java:707) at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:851) at javax.servlet.http.HttpServlet.service(HttpServlet.java:790) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:158) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.filterAndRecordMetrics(WebMvcMetricsFilter.java:126) at org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter.doFilterInternal(WebMvcMetricsFilter.java:111) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:123) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at com.blockchain.server.base.filter.XssFilter.doFilter(XssFilter.java:56) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter.doFilterInternal(HttpTraceFilter.java:90) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:109) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.session.web.http.SessionRepositoryFilter.doFilterInternal(SessionRepositoryFilter.java:147) at org.springframework.session.web.http.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:81) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198) at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496) at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140) at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81) at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87) at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342) at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803) at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790) at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1468) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:748)Caused by: com.lorne.core.framework.exception.ServiceException: update TxGroup error, groupId:kcxZJOnG at com.codingapi.tx.aop.service.impl.TxRunningTransactionServerImpl.execute(TxRunningTransactionServerImpl.java:90) at com.codingapi.tx.aop.service.impl.AspectBeforeServiceImpl.around(AspectBeforeServiceImpl.java:58) at com.codingapi.tx.springcloud.interceptor.TxManagerInterceptor.around(TxManagerInterceptor.java:32) at com.codingapi.tx.springcloud.interceptor.TransactionAspect.around(TransactionAspect.java:39) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644) at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633) at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:174) at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:92) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:185) at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:688) ... 76 more15:53:57.882 [http-nio-18301-exec-4] INFO c.c.t.s.l.ServerListener - [onApplicationEvent,27] - onApplicationEvent -&gt; onApplicationEvent. 15:53:57.883 [TxInit-thread] INFO c.c.t.l.s.i.InitServiceImpl - [start,24] - socket-start..15:53:57.903 [Thread-123] INFO c.c.t.d.r.LCNDBConnection - [transaction,176] - lcn transaction over, res -&gt; groupId:kcxZJOnG and state is rollback 就是这个错误，之前我在测试机上面，看到多次，找不到原因 然后，这个3s就是之前用到了服务降级，在配置文件中 123456789hystrix: command: default: execution: timeout: enabled: true #如果设置为false execution.isolation.thread.timeoutInMilliseconds配置无效 isolation: thread: timeoutInMilliseconds: 3000 #这个超时时间，就是消费方调用服务方的超时时间，3s内服务方没有返回就会报错 网上找到三种解决方法： 12345678910111、设置Hystrix的超时时间，例如设置超时时间为5s hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds: 50002、不设置Hystrix的超时时间 hystrix.command.default.execution.timeout.enabled: false3、禁用Hystrix feign.hystrix.enabled: false 先试试直接关了：feign.hystrix.enabled: false执行了差不多5s后，报了如下超时错误 1216:07:36.481 [http-nio-10505-exec-1] DEBUG c.b.s.p.f.BTCFeign - [log,70] - [BTCFeign#test] &lt;--- ERROR SocketTimeoutException: Read timed out (5780ms)16:07:36.482 [http-nio-10505-exec-1] INFO c.c.t.d.r.LCNStartConnection - [rollback,99] - rollback label 应该还有一个超时时间，是的在hystrix禁用后，feign调用的超时时间和下面两个配置有关 123456789101112131415#feign的配置feign: hystrix: #开启熔断器 enabled: false client: config: default: connectTimeout: 5000 readTimeout: 5000 loggerLevel: BASIC#ribbon的配置,它的配置ribbon: ReadTimeout: 60000 ConnectTimeout: 60000 feign的超时： hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 在配置了hystrix情况下，超时时间和hystrix配置相关； 如果feign和ribbon都没有配置，此时hystrix的这个配置是无效的，取默认值1s； 如果配置了feign或者ribbon，且feign或ribbon的值小于hystrix配置的，hystrix的配置项依然无效，会取feign或者ribbon的值； feign和ribbon同时配置，feign的优先级高； 所以，hystrix的配置时间时，feign或ribbon必须配置要一个，且时间要小于他们； 在没有配置hystrix情况下，也没有feign.client.config.connectTimeout|readTimeout，没有ribbon.ReadTimeout|ConnectTimeout配置，默认是超时时间是1s； 在没有配置hystrix情况下，配置了feign.client.config和ribbon，前者优于后者，如果没有配置feign.client.config就取ribbon的配置时间","link":"/2019/11/19/feign-time-out-problem-with-txlcn/"},{"title":"彻底放弃自己写博客系统的前端计划","text":"这个感觉直接使用hexo去做好多了，就是管理文章麻烦点，前端不用写，样式还好看。 NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 clooeer 1select * from catering_orders 123public void test(){ int a = 0;} _.compactUnderscore.js12_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3] 这个是more后面的。","link":"/2020/09/24/give-up-to-do-front-project/"},{"title":"hashmap的简单认识","text":"1.hashmap实现了map接口，是线程不安全的，插入的数据key值不能重复，key和value可以为null。 2.hashmap底层是一个Entry数组+链表。 3.插入一个值，根据key值的hashcode来进行hash运算，得到数组的下标，确定插入位置，如果插入位置已经有了元素，作为链表头部插入。 4.下标值的计算是key的hashcode，h&amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 5.经过这样的计算下标值可以使元素在数组中均匀分布。 6.hashmap底层数组的初始长度是16，负载因子0.75。当数组长度超过16*0.75=12时，数组会扩容成16*2=32。此时要重新计算每个元素在数组中的位置。 7.hashmap中数组长度总是2的n次方。","link":"/2019/03/03/hashmap-demo/"},{"title":"Hibernate整合MySql报错信息","text":"1.hibernate插入错误。ERROR&nbsp;org.hibernate.engine.jdbc.spi.SqlExceptionHelper&nbsp;-&nbsp;You&nbsp;have&nbsp;an&nbsp;error&nbsp;in&nbsp;your&nbsp;SQL&nbsp;syntax;&nbsp;check&nbsp;the&nbsp;manual&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;your&nbsp;MySQL&nbsp;server&nbsp;version&nbsp;for&nbsp;the&nbsp;right&nbsp;syntax&nbsp;to&nbsp;use&nbsp;near&nbsp;'group,&nbsp;identity,&nbsp;salt,&nbsp;status)&nbsp;values&nbsp;('201417010128',&nbsp;0,&nbsp;0,&nbsp;'0c67c5eb515aa6e958'&nbsp;at&nbsp;line&nbsp;1原因：group是关键字。。2.ERROR org.hibernate.engine.jdbc.spi.SqlExceptionHelper - Field 'mobile' doesn't have a default valueField&nbsp;'mobile'&nbsp;doesn't&nbsp;have&nbsp;a&nbsp;default&nbsp;value原因：这个问题我在公司前两天也遇到过，向表中新增字段后，由于设置了not null，在插入的时候该字段如果为null就会报错。可以将该字段在数据库设置一个默认值。在mysql5.0.2以前，mysql对非法值检查并不严厉，而且为了数据输入还会强制将他们变为合法值。在5.0.2以后的版本中，保留了以前的默认行为，但你可以为不良值选择更传统的处理方法，从而使得服务器能够拒绝并放弃出现不良值的语句。3.org.springframework.dao.DataIntegrityViolationException: not-null property references a null or transient value :org.springframework.dao.DataIntegrityViolationException:&nbsp;not-null&nbsp;property&nbsp;references&nbsp;a&nbsp;null&nbsp;or&nbsp;transient&nbsp;value&nbsp;:原因：在.hbm.xml文件设置的not-null不是mysql里面的not-null，在插入的时候会报错。4.java.lang.ClassCastException: org.springframework.orm.hibernate5.SessionHolder cannot be cast to org.springframework.orm.hibernate4.SessionHolderjava.lang.ClassCastException:&nbsp;org.springframework.orm.hibernate5.SessionHolder&nbsp;cannot&nbsp;be&nbsp;cast&nbsp;to&nbsp;org.springframework.orm.hibernate4.SessionHolder原因：原因很明显，所用的hibernate版本为5.0.12，Spring版本为4.3.14，在用HibernateDaoSupport时引用了hibernate4对应的版本。在Spring提供的orm包中，存在hibernate3、4、5版本。修改为hibernate5的support。import&nbsp;org.springframework.orm.hibernate5.support.HibernateDaoSupport;-------------------------------2018-04-20&nbsp;18:54:54-----------------------------------5.org.hibernate.HibernateException: HHH000142: Javassist Enhancement failed描述：数据库没有做外键关联，hibernate实体类里面有对象关系解决方法：1.在配置这个类的配置文件中many-to-one标签中添加fetch=“join” 这个还会报异常，不过可以查询出来了 2.在配置这个类的配置文件中many-to-one标签中添加lazy=“false”,不延迟加载,就没有问题了6.should be mapped with insert=&quot;false&quot; update=&quot;false&quot;描述：在实体类中配置实体关系的时候，我既想保留属性列，又想增加实体关系。出现了这个错误解决办法：在标签内增加&nbsp;insert=&quot;false&quot; update=&quot;false&quot;-------------------------------2018-04-22 00:03:05-----------------------------------7.org.hibernate.HibernateException: createQuery is not valid without active transaction描述：是dao中使用sessionFactory.getCurrentSession()方法获得session，在配置文件中写了这个&lt;prop&nbsp;key=&quot;hibernate.current_session_context_class&quot;&gt;thread&lt;/prop&gt;解决办法：删掉上面这个配置，参考。8.at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:663) ~[jackson-databind-2.5.0.jar:2.5.0]描述：jackson 序列化Hibernate entity类无限递归的问题。解决方法：使用@JsonIgnore，@JsonIdentityInfo，@JsonManagedReference and @JsonBackReference这几个注解，我直接放弃了那个表的实体关联，手动查询。","link":"/2018/03/25/hibernate-and-mysql-errors/"},{"title":"RandomAccess这个空接口有何用","text":"RandomAccess这个空接口有何用？ 在学习 Java 集合时， 最先学习的便是 List 中的 ArrayList 和 LinkedList， 学习集合很关键的是学习其源码， 了解底层实现方式， 那么今天就讲讲 ArrayList 实现的一个接口 RandomAccess。 好奇心的产生查看 ArrayList 的源码， 发现它实现了 RandomAccess 这个接口， 出于好奇点进去看看， 结果发现这接口是空的， 这当然引发了更大的好奇心：这空架子到底有何用？ 深入探究JDK 官方文档是不可少的工具， 先看看它是怎么说的：RandomAccess 是 List 实现所使用的标记接口，用来表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。 标记接口（Marker）：这就说明了 RandomAccess 为空的原因，这个接口的功能仅仅起到标记的作用。 这不是与序列化接口 Serializable 差不多吗？ 只要你认真观察， 其实不只这一个标记接口， 实际上 ArrayList 还实现了另外两个这样的空接口： Cloneable 接口 ：实现了 Cloneable 接口，以指示 Object.clone() 方法可以合法地对该类实例进行按字段复制。 如果在没有实现 Cloneable 接口的实例上调用 Object 的 clone 方法，则会导致抛出 CloneNotSupportedException 异常。 Serializable 接口： 类通过实现 java.io.Serializable 接口以启用其序列化功能。未实现此接口的类将无法使其任何状态序列化或反序列化。 继续探讨标记接口都有什么作用呢？ 继续讨论 RandomAccess 的作用，其他两个在此不作讨论。 如果 List 子类实现了 RandomAccess 接口，那表示它能快速随机访问存储的元素， 这时候你想到的可能是数组， 通过下标 index 访问， 实现了该接口的 ArrayList 底层实现就是数组， 同样是通过下标访问， 只是我们需要用 get() 方法的形式 ， ArrayList底层仍然是数组的访问形式。 同时你应该想到链表， LinkedList 底层实现是链表， LinkedList 没有实现 RandomAccess 接口，发现这一点就是突破问题的关键点。 数组支持随机访问， 查询速度快， 增删元素慢； 链表支持顺序访问， 查询速度慢， 增删元素快。所以对应的 ArrayList 查询速度快，LinkedList 查询速度慢， RandomAccess 这个标记接口就是标记能够随机访问元素的集合， 简单来说就是底层是数组实现的集合。 为了提升性能，在遍历集合前，我们便可以通过 instanceof 做判断， 选择合适的集合遍历方式，当数据量很大时， 就能大大提升性能。 随机访问列表使用循环遍历，顺序访问列表使用迭代器遍历。 先看看 RandomAccess 的使用方式: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package iureh.servers.practice.j2se.collection;import java.util.*;/** * @author: rui * @date: 2019/10/17 0017 16:31 * @description: 根据集合框架的不同选择合适的遍历方式 */public class RandomAccessTest { static void choose(List list){ //实现类带有RandomAccess接口，采用for循环遍历 if(list instanceof RandomAccess){ System.out.print(\"带有RandomAcess接口标记\"); }else{ System.out.print(\"不带有RandomAcess接口标记\"); } long start = System.currentTimeMillis(); for(int i=0;i&lt;list.size();i++){ Object o = list.get(i); String s = o.toString(); } System.out.println(\"FOR用时：\"+(System.currentTimeMillis()-start)+\"ms\"); Iterator it = list.iterator(); long start2 = System.currentTimeMillis(); while (it.hasNext()){ Object o = it.next(); String s = o.toString(); } System.out.println(\"Iterator用时：\"+(System.currentTimeMillis()-start2)+\"ms\"); } public static void main(String[] args) { List arrayList = new ArrayList(); List linkList = new LinkedList(); for(int i=0;i&lt;100000;i++){ arrayList.add(i+\"\"); linkList.add(i+\"\"); } choose(arrayList); choose(linkList); }} 结果： ArrayList:for 循环遍历时间: 2435迭代器遍历时间: 2435 LinkedList:for 循环遍历时间: 2435迭代器遍历时间: 3 结论根据结果我们可以得出结论：ArrayList 使用 for循环遍历优于迭代器遍历LinkedList 使用 迭代器遍历优于 for 循环遍历 根据以上结论便可利用 RandomAccess 在遍历前进行判断，根据 List 的不同子类选择不同的遍历方式， 提升算法性能。 注：原文中例子有些问题，用的自己的","link":"/2019/11/19/how-to-use-interface-randomaccess/"},{"title":"2017.12.09面试","text":"下午的时候，去了一家公司面试，做了很久的车，刚开始公交还坐反了。。面试题分为单选，多选和填空试卷涉及到了struts、hibernate、spring等框架，数据库考到了Oracle数据库，没有mysql，关于oracle方面的题基本算是蒙的，后来面试的时候，面试官是一个搞研发的大叔，我还记得的问题有：1.servlet和jsp的区别？JSP与Servlet主要有两方面的不同：编译：JSP修改后可以立即看到结果，不需要编译；而Servelt缺需要编译。转换：JSP是动态网页开发技术，是运行在服务器端的脚本语言，而Servlet是web服务器端编程技术。所以JSP运行时就是转换为Servlet，也就是java程序来执行。SERVLET是SUN早期推出的，其功能比较强劲，体系设计也很先进，只是，它输出HTML语句还是采用了老的CGI方式，是一句一句输出，所以，编写和修改HTML非常不方便。后来SUN推出了类似于ASP的镶嵌型的JSP，把JSP TAG镶嵌到HTML语句中，这样，就大大简化和方便了网页的设计和修改。这儿也就产生了一个区别了，SERVLET是往JAVA代码中嵌HTML元素，JSP是往HTML里嵌JAVA代码。如果，我们这样嵌来嵌去的话代码肯定是混乱不堪，不容易理解。对于后期的维护将是一大难题！所以说，jsp比较适合与承担view这个角色。而servlet比较适合与承担Control这个角色。理论上讲用servlet来写的东西，都可以用jsp完成。虽然JSP基本上实现了Servlet的功能，但JSP在性能上是无法与Servlet相比的。参考自：http://blog.csdn.net/epm_kf6_10/article/details/48602117&amp;&amp;http://blog.csdn.net/yaohaibing576082210/article/details/58554442.事务的作用？&nbsp;&nbsp;事务（Transaction）是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。通过事务，SQL Server能将逻辑相关的一组操作绑定在一起，以便服务器保持数据的完整性。就是为了保持事物的完整性、一致性。3.转发和重定向的区别、为什么重定向request里面不带有数据重定向：以前的request中存放的变量全部失效，并进入一个新的request作用域。&nbsp;转发：以前的request中存放的变量不会失效，就像把两个页面拼到了一起。转发过程：客户首先发送一个请求到服务器端，服务器端发现匹配的servlet，并指定它去执行，当这个servlet执行完之后，它要调用getRequestDispacther()方法，把请求转发给指定的student_list.jsp,整个流程都是在服务器端完成的，而且是在同一个请求里面完成的，因此servlet和jsp共享的是同一个request，在servlet里面放的所有东西，在student_list中都能取出来，因此，student_list能把结果getAttribute()出来，getAttribute()出来后执行完把结果返回给客户端。整个过程是一个请求，一个响应。重定向过程：客户发送一个请求到服务器，服务器匹配servlet，这都和请求转发一样，servlet处理完之后调用了sendRedirect()这个方法，这个方法是response的方法，所以，当这个servlet处理完之后，看到response.senRedirect()方法，立即向客户端返回这个响应，响应行告诉客户端你必须要再发送一个请求，去访问student_list.jsp，紧接着客户端受到这个请求后，立刻发出一个新的请求，去请求student_list.jsp,这里两个请求互不干扰，相互独立，在前面request里面setAttribute()的任何东西，在后面的request里面都获得不了。可见，在sendRedirect()里面是两个请求，两个响应。转发在服务器端完成的；重定向是在客户端完成的转发的速度快；重定向速度慢转发的是同一次请求；重定向是两次不同请求转发不会执行转发后的代码；重定向会执行重定向之后的代码转发地址栏没有变化；重定向地址栏有变化转发必须是在同一台服务器下完成；重定向可以在不同的服务器下完成参考自：http://blog.csdn.net/lishehe/article/details/23133105这三个问题，以及还有一些问题我都回答得不是很好。。。感觉回答问题的时候，没有想得那么多。。经验啊。确实是我想得不够深入，理解得不够彻底。下次再战!!还问了啥来着？？记起来了再来写。。","link":"/2017/12/11/interview-2017-12-09/"},{"title":"JAVA设计模式之单例模式","text":"概念： java中单例模式是一种常见的设计模式，单例模式的写法有好几种，这里主要介绍三种：懒汉式单例、饿汉式单例、登记式单例。 单例模式有以下特点： 1、单例类只能有一个实例。 2、单例类必须自己创建自己的唯一实例。 3、单例类必须给所有其他对象提供这一实例。主要优点：1、提供了对唯一实例的受控访问。2、由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。3、允许可变数目的实例。&nbsp;主要缺点：1、由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。2、单例类的职责过重，在一定程度上违背了“单一职责原则”。3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。 单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。一、懒汉式单例 //懒汉式单例类.在第一次调用的时候实例化自己&nbsp;&nbsp;&nbsp; public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton()&nbsp;{}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Singleton&nbsp;single=null;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//静态工厂方法&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton&nbsp;getInstance()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(single&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;single;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; }Singleton通过将构造方法限定为private避免了类在外部被实例化，在同一个虚拟机范围内，Singleton的唯一实例只能通过getInstance()方法访问。（事实上，通过Java反射机制是能够实例化构造方法为private的类的，那基本上会使所有的Java单例实现失效。此问题在此处不做讨论，姑且掩耳盗铃地认为反射机制不存在。）但是以上懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例，要实现线程安全，有以下三种方式，都是对getInstance这个方法改造，保证了懒汉式单例的线程安全，如果你第一次接触单例模式，对线程安全不是很了解，可以先跳过下面这三小条，去看饿汉式单例，等看完后面再回头考虑线程安全的问题：1、在getInstance方法上加同步public&nbsp;static&nbsp;synchronized&nbsp;Singleton&nbsp;getInstance()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(single&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;single&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;single;&nbsp;&nbsp; }2、双重检查锁定public&nbsp;static&nbsp;Singleton&nbsp;getInstance()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(singleton&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(Singleton.class)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(singleton&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;singleton&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;singleton;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}3、静态内部类public&nbsp;class&nbsp;Singleton&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;class&nbsp;LazyHolder&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;Singleton&nbsp;INSTANCE&nbsp;=&nbsp;new&nbsp;Singleton();&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton&nbsp;(){}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;final&nbsp;Singleton&nbsp;getInstance()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;LazyHolder.INSTANCE;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; }这种比上面1、2都好一些，既实现了线程安全，又避免了同步带来的性能影响。二、饿汉式单例//饿汉式单例类.在类初始化时，已经自行实例化&nbsp;&nbsp;&nbsp; public&nbsp;class&nbsp;Singleton1&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;Singleton1()&nbsp;{}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;final&nbsp;Singleton1&nbsp;single&nbsp;=&nbsp;new&nbsp;Singleton1();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//静态工厂方法&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton1&nbsp;getInstance()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;single;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; }饿汉式在类创建的同时就已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。三、登记式单例(可忽略)//类似Spring里面的方法，将类名注册，下次从里面直接获取。&nbsp;&nbsp; public&nbsp;class&nbsp;Singleton3&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;Map&lt;String,Singleton3&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;HashMap&lt;String,Singleton3&gt;();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;static{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton3&nbsp;single&nbsp;=&nbsp;new&nbsp;Singleton3();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(single.getClass().getName(),&nbsp;single);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//保护的默认构造子&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;protected&nbsp;Singleton3(){}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//静态工厂方法,返还此类惟一的实例&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Singleton3&nbsp;getInstance(String&nbsp;name)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(name&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;Singleton3.class.getName();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;name&nbsp;==&nbsp;null&quot;+&quot;---&gt;name=&quot;+name);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(map.get(name)&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map.put(name,&nbsp;(Singleton3)&nbsp;Class.forName(name).newInstance());&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(InstantiationException&nbsp;e)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(IllegalAccessException&nbsp;e)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(ClassNotFoundException&nbsp;e)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;map.get(name);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//一个示意性的商业方法&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;about()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;Hello,&nbsp;I&nbsp;am&nbsp;RegSingleton.&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Singleton3&nbsp;single3&nbsp;=&nbsp;Singleton3.getInstance(null);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(single3.about());&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; }登记式单例实际上维护了一组单例类的实例，将这些实例存放在一个Map（登记薄）中，对于已经登记过的实例，则从Map直接返回，对于没有登记的，则先登记，然后返回。&nbsp;这里我对登记式单例标记了可忽略，我的理解来说，首先它用的比较少，另外其实内部实现还是用的饿汉式单例，因为其中的static方法块，它的单例在类被装载的时候就被实例化了。饿汉式和懒汉式区别从名字上来说，饿汉和懒汉，饿汉就是类一旦加载，就把单例初始化完成，保证getInstance的时候，单例是已经存在的了，而懒汉比较懒，只有当调用getInstance的时候，才回去初始化这个单例。另外从以下两点再区分以下这两种方式：1、线程安全：饿汉式天生就是线程安全的，可以直接用于多线程而不会出现问题，懒汉式本身是非线程安全的，为了实现线程安全有几种写法，分别是上面的1、2、3，这三种实现在资源加载和性能方面有些区别。2、资源加载和性能：饿汉式在类创建的同时就实例化一个静态对象出来，不管之后会不会使用这个单例，都会占据一定的内存，但是相应的，在第一次调用时速度也会更快，因为其资源已经初始化完成，而懒汉式顾名思义，会延迟加载，在第一次使用该单例的时候才会实例化对象出来，第一次调用时要做初始化，如果要做的工作比较多，性能上会有些延迟，之后就和饿汉式一样了。至于1、2、3这三种实现又有些区别，第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。什么是线程安全？如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。或者说：一个类或者程序所提供的接口对于线程来说是原子操作，或者多个线程之间的切换不会导致该接口的执行结果存在二义性,也就是说我们不用考虑同步的问题，那就是线程安全的。应用:以下是一个单例类使用的例子，以懒汉式为例，这里为了保证线程安全，使用了双重检查锁定的方式：public&nbsp;class&nbsp;TestSingleton&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;name&nbsp;=&nbsp;null;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;TestSingleton()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;static&nbsp;volatile&nbsp;TestSingleton&nbsp;instance&nbsp;=&nbsp;null;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;TestSingleton&nbsp;getInstance()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;synchronized&nbsp;(TestSingleton.class)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(instance&nbsp;==&nbsp;null)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance&nbsp;=&nbsp;new&nbsp;TestSingleton();&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;instance;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;String&nbsp;getName()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;name;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;setName(String&nbsp;name)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name&nbsp;=&nbsp;name;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;printInfo()&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;the&nbsp;name&nbsp;is&nbsp;&quot;&nbsp;+&nbsp;name);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp; }可以看到里面加了volatile关键字来声明单例对象，既然synchronized已经起到了多线程下原子性、有序性、可见性的作用，为什么还要加volatile呢，原因已经在下面评论中提到，public&nbsp;class&nbsp;TMain&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args){&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TestStream&nbsp;ts1&nbsp;=&nbsp;TestSingleton.getInstance();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ts1.setName(&quot;jason&quot;);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TestStream&nbsp;ts2&nbsp;=&nbsp;TestSingleton.getInstance();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ts2.setName(&quot;0539&quot;);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ts1.printInfo();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ts2.printInfo();&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(ts1&nbsp;==&nbsp;ts2){&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;创建的是同一个实例&quot;);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;创建的不是同一个实例&quot;);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp; }&nbsp;运行结果：结论：由结果可以得知单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。对于单例模式的几种实现方式，知道饿汉式和懒汉式的区别，线程安全，资源加载的时机，还有懒汉式为了实现线程安全的3种方式的细微差别。参考[1]：http://blog.csdn.net/jason0539/article/details/23297037/参考[2]：http://www.iteye.com/topic/652440参考[3]：http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html","link":"/2017/12/14/java-design-pattern-singleton/"},{"title":"解决Gradle项目编译后没有mybatisMapper文件","text":"在gradle.build文件中加上下面一句： sourceSets.main.resources.srcDirs = [\"src/main/java\",\"src/main/resources\"] gradle就会把java目录也当成资源目录，编译后会将mapper文件输出至目录","link":"/2018/12/12/gradle-build-no-mapper/"},{"title":"Java面试题","text":"1.说一说你理解的面向对象思想？ &nbsp;","link":"/2019/06/08/java-interview-questions/"},{"title":"11111","text":"原译文标题为：Loser应该知道的 6 个残酷人生事实（血泪翻译），译者（天理难容）没有翻译 Loser， 这个词不难理解——失败者。但是，我把 Loser 改成了「屌丝」。 来自: 天理难容 (Weixu@Rutgers) 2013-01-20 09:24:29 译注：此文转载并翻译自 cracked.com，文章中很大一块其实和拖延症有关的所以发在这里。 【补注1：最初本文发在一个另一个论坛，我用了 loser 这个词来吸引眼球，但转发豆瓣的时候忘记改标题了。现在为了 SEO 的目的我就不修改标题，厚着脸皮继续哗众取宠了。】 【补注2：本文是我看原文后 2 小时粗译出来的。如果觉得译文生涩，可以搜索一下原文标题看原版。感谢大家推荐和关注。现在关注的人多了，我深感责任重大，正准备重新翻译一遍。鉴于最近忙碌的程度，二度翻译遥遥无期】 原文标题：6 Harsh Truths That Will Make You a Better Person六个可以让你变得更强大的残酷事实by David Wong 【补注 by justjavac：我在译文的基础上又做了一些修改，主要是语法和修辞上。感谢「天理难容 (Weixu@Rutgers)」和原作者。】 正文： 如果你的职业道路非常顺利，你的生活美满感情顺利，你可以不用读这篇文章。 祝你一天愉快，这篇文章不是为你写的。 你做的非常出色，我们都为你自豪。 对于其余的人来说，我希望你做一件事情：说出 5 件你引以为豪的事情。 写在纸上也好，或者喊出来也好都可以。 但这里有一个条件：你不可以列出你「是」怎样的人（比如，我是一个温柔的人，我很诚实）， 只能列出你「做」的事情（比如，我刚获得了全国象棋冠军，我做的 chili 是全麻省最好的）。 如果你发现很难列出五件事情，这篇文章就是为你所写的。 而且你他娘的肯定一边听一边心里会不舒服。 我的感受是，如果有人在 1995 年的时候跟我讲这些事情就好了。 6：这个世界只关心你能给予什么我们假设一下你最爱的亲人在大街上被枪击了。 TA 一边失血一边尖叫。 一个路人冲上来说「让一下」。 他仔细检查了伤口并拿出一把小刀准备在大街上动手术取出子弹。 你问他：「你是医生吗？」 他回答说：「不是」 你说：「你知道你要做什么，对吧？你是不是退伍的军医，还是……」 这个时候那个路人感觉有点不快了。 他告诉你说他是一个好人，是一个诚实的人，他上班从来不迟到。 他告诉你说他是一个孝顺的儿子。 业余生活丰富，生活非常富足。 而且～他还说他从不说脏话…… 你有点疑惑，说：「这 TMD 和我亲人被枪击躺在马路上有什么关系？ 我需要一个可以在伤口上动手术的人！你到底能不能做？」 现在这个路人非常生气了——为什么你就那么自私肤浅呢？ 你难道不在乎他的那些优良品德么？ 他刚才不对你说他总是记住女友的生日吗？ 他有那么多优良品质，你为什么就抓着他会不会外科手术这个事实不放呢？ 在那个疯狂的情形下，你会用你沾满鲜血的双手用力摇晃他的肩膀， 大喊道：「废话！你说的那些优良品质都是屁话，因为在当前情况下我只需要一个可以止血动手术的人！ 你这个神经病给我滚！！！」 所以，这就是我要说的第一点成人世界的残酷事实： 你其实天天都身处于上述的「当前情况」之中。 只不过换作你是那个喋喋不休的好心路人，而社会上其他所有人都换作成那个流血的伤者。 如果你想知道为什么社会对你不屑，或者你为什么从不受到尊重， 这是因为社会充满了【需要某样东西】的人。 他们需要人来造房子，他们需要食物，他们需要娱乐，他们需要人来满足性欲。 你从出生开始就进入了这样的需要解决人们需求的社会系统。 你要么选择学习某种技能担当某样角色满足他人的需要，要么就选择被社会抛弃。 这个社会不在乎你有多么善良，礼貌，无私。 你会变穷，你会没有朋友，你会被遗弃。 但这是不是说我们要刻版、自私呢？ 爱和温柔重要吗？ 当然了，但前提是这些爱是别人需要的，也是从其他人那里得不到的。 否则的话…… 5：别去相信嬉皮士的话 (Hippies are wrong)【原文此处引用了一段视频。 国内看不了 Youtube。 可以翻墙且听力没问题的可以此处看：http://www.youtube.com/watch?feature=player_embedded&amp;v=8kZg_ALxEz0 】 对于那些无法看视频的读者，这是一段著名的影院神片 Glengarry Glenn Ross 里 Alec Baldwin 的演讲。 Baldwin 的角色——你会假设是反角——对一屋子的销售员疯狂施压，警告他们说他们都会被解雇， 除非他们可以搞定他们手上的单子。 「好人？关我屁事！慈父？去你妈的！回你的家和你孩子玩去！如果你想在这里工作，给我敲定手上的单子」 非常残酷、粗鲁、甚至有点疯狂。 可是，这恰恰是这个社会对你期望的最诚实的写照。 不同的是，在现实世界里，人们认为那样讲话太粗鲁了对你不礼貌， 于是他们干脆什么都不说眼看着你失败。 这个电影片段改变我的人生。 我如果知道怎么做的话，会把它录成闹钟每天早上叫我起床。 Baldwin 因此还拿了奥斯卡奖，而这个片段是他整个电影唯一出场的场景！ 正如前人已经分析过，这段演讲精彩之处在于，一般的人会理解为 「天哪，我要有这么一个混蛋老板会怎样啊？」。 而另一半人却会想「太 TMD 励志了！我现在就想去上班做业务去！」 或者，有一个心理学家写道：「如果当时你在那个房间里，你们中的一些人会明白这是工作， 会从那段演讲里吸收能量，就像一个球队教练冲你大骂一样。 你会觉得‘这家伙太有能耐了’。 而另一些人会非常介意，认为这个老板是混蛋，你没有权利跟我这样说话。」 以上节选自一篇对于「hipster（这个词很难翻译，姑且翻译为非主流潮人）」的批判文章。 文章解释了这些人为什么会难找工作，并指出上述两种不同的态度——受刺激 VS 受激励——很大程度上决定你是否在现实生活中能成功。 比如说，有人会引用搏击俱乐部里的经典台词「You are not your job」。 但事实上，你完完全全就是你的 job（职责）。 当然了，你的职责和你为公司的服务不是一回事请，但其实你只不过是你所有有用技能经验的综合体罢了。 技能是某一个个体能为社会中其他人提供的有用服务。 但别搞错了，你的「职责」——你为他人提供的有用服务——就是你的全部。 这就是为什么外科医生比喜剧作家更受到尊重。 也是为什么机修工比无业潮人更受到尊重。 如果你的死讯能登上新闻，这说明你的工作已经成为了你的标签。 搏击俱乐部里 Tyler 说 You are not your job，但他同时又操办了一家成功的肥皂公司同时成为了社会运动的领导人。 He was totally his job （这句不翻译比较好理解）。 我们再这样理解一下：你还记得 Chick-fil-A 餐厅反对同性恋婚姻么？ 不论嬉皮们如何抗议，公司还不是照样卖出了成千上万的汉堡？ 这不是说顾客们认可他们，而是因为他们成功地完成了履行了他们的职责——做好吃的汉堡。 这一点才是最关键的。 你不一定非要从心里喜欢这个事实。 我也不喜欢我生日的时候天下雨。 但天还是要下雨。 人们有需求，人们会认可能够满足他们需求的人。 世界就是通过这么简单的机制运行的，谁也改变不了。 如果你抗议说，我不是肤浅的物质主义者，金钱不是万能的，我只能说：「我有说过金钱吗？ 说明你没看懂我的要点。」 4：你所做的事情不一定要换成钱，但一定要有益于他人那么我们换一个非金钱的例子好了。 这个网站(cracked.com)主要面向 20 出头的男性。 我每天都要从邮箱里收到一大堆挫男抱怨女人不愿意接近他们，虽然他们是世界上最 nice 的男人。 我可以解释他们的思路有什么问题，不过最好是让 Alec Baldwin 解释最好。 （译注：此处再次引用上述视频，我真的建议大家去看那个片段！） 在我们说的例子里，Baldwin 就是你生活里那个女神。 他们当然不会像 Baldwin 的角色那样粗鲁直接——社会教育我们不要对别人那么「诚实」—— 但问题是一样的：「你是好人？关我屁事！想在这里工作，就给我搞定工作。」 所以，你有什么感想呢？ 你对在书店里遇到的女神每天白日梦意淫，为她午餐不吃色拉感到惋惜。 她 10 年后会成为一个外科医生，你呢？ 「什么？你是说除非我找到一个好工作赚大钱否则不可能把到女神？」 不！你的大脑跳跃太快了，因此你可以给自己一个理由认为所有拒绝你的女神都是肤浅自私的。 我在这里就问一个问题：你给予了什么？你聪明么？幽默吗？情趣吗？天才？雄心？创意？ 好，那你做什么事情能向这个世界证明自己的优点呢？ 不要跟我说你是个好人——这是最起码的。 你的女神每天有三打的男人对她「好」。 用我们上文的例子来说，伤者在大街上流血，你到底会不会开刀？ 「我不歧视女人，不歧视种族，不贪婪，不肤浅，也不虐待人！我和那些屌不垃几的男人不一样。」 很抱歉，如果你所能做的事情只不过是你「没有」一堆缺点，就 TMD 给我从伤者身边滚出去！ 我们有的是风趣、英俊、事业成功的男人来帮助你的女神。 伤到你自尊了么？有一点？那现在怎样呢？ 你想碎碎念呢，还是打算学习怎么去做手术治疗那个伤者？ 取决于你。 但你不要去抱怨为什么女神就喜欢找你口中的坏男人。 她们吃这套是因为那些屌不拉几的男人有其他东西可以满足你的女神。 「但我是一个聆听者！」 是吗？你可以坐在女神身边几个小时听她念叨？你猜怎么着？ 角落里还有另一个男人可以这样做，他还是吉他高手！ 你如果不停地说你是一个好人，就像一个餐厅说他们的卖点是他们的食物不会让你拉肚子一样， 就像一部电影的标题是「This Movie is in English」。 这就是为什么你可以做一个好人但仍然觉得自己是 loser（屌丝）。 3：你恨自己是因为你无所作为「所以你的意思是要我去买一本教我如何把妹的书么？」 当然不是，除非那本书的第一章是「让自己变成女孩子愿意接近的人」。 因为这一步总是容易被忽略——人们总是问「我怎么能找到工作？」 而不是「我如何成为雇主愿意雇用的人？」； 人们总是问「怎么让女孩喜欢我？」而不是「我怎么成为女孩喜欢的人？」。 对吧？因为后者往往要求你放弃自己喜欢的爱好，注重外表，天知道还要做其他什么牺牲。 你甚至还可能要改变你的天性。 「但是为什么我不能就去找一个喜欢原本的我的人呢？」 答案很简单：人是有需求的。 别忘记我们的例子：伤者在流血，而你所做的只是抱怨找不到会自动愈合的伤口？ 【此处插入一段 Youtube 上点击率很高的猥琐街头艺人表演的视频】 每个人看了上面这段视频都会会心一笑。 你能为人们带来笑声么？为什么不呢？ 是为什么阻止你穿上猥琐的衣服在街头边唱边甩鸡鸡呢？ 那家伙似乎知道赢得掌声的门道……做怪事……总比什么都不做好…… 「但是我什么都不擅长！」我有好消息告诉你：如果你尝试反复练习做一件事情， 任何事情，你都可以擅长此事。我小时候可能是全世界最糟糕的作者。 到了 25 岁的时候稍微好那么一点点。 但当我职场失意的时候，我用业余时间写作长达八年，一周写一篇文章，直到它为我换回了钞票。 我花了 13 年时间才能登上纽约时报畅销书榜单。 我大概花了 20000 个小时才慢慢磨快了我拙劣的文笔。 不希望花那么多时间磨练一门技术？那么我有好消息和坏消息告诉你。 好消息是漫长的磨练可以让你慢慢走出困境——我忍受了多年琐碎的办公室工作， 因为我知道我同时在学习一门技能。 人们半途而废是因为要看到结果实在是太漫长了，同时也是因为他们没有意识到「结果」就是过程本身。 坏消息是你别无选择。「想继续在这里工作？——那就给我搞定手里的单子」 从我个人角度出发看，你并不是因为缺乏自信而恨自己，或者是因为别人羞辱你。 你恨自己是因为你【什么都不做】。 连你自己都不能爱「原本的自我」——这就是为什么你很可悲，不断写私信问我如何处理你的生活问题。 自己扳手指算一下：你有多少时间是在消费别人创造的东西（电视，音乐，电玩，网站）而不是生产你自己的东西？ 只有你的「产出」才能为你添加作为人的价值。 如果你听到这里听不下去了，并且用你从小听到大的陈词滥调回应说： 「人的内在才是最重要的」，那么我只能说……（接下文） 2：你的内在只有通过所做的事情才能表现出来在我所从事的行业里，我认识无数有理想的作家。 他们认为自己是作家，他们在聚会上介绍自己是作家，他们拥有一颗作家的热心。 他们只缺乏最后的一步：写点 TMD 像样的东西出来！！！！ 是吗？难道「写点东西」就是真正决定谁是谁不是真正「作家」的标准吗？ 我的天哪！！！当然是了！ 这恰恰是对我以上所说一切最常见的反驳，也是对你生活中批评声音最常见的反驳。 这是你不断对你自己暗示以逃避能帮你改善自我的刻苦工作的理由。 「我知道我的内在是一个很好的人」。 你也会听到人说「我做我自己」。 不要误会我的意思：你的内在非常重要。 一个男人如果为了他的家庭从无到有造出一栋房子完全是因为他的内在是一个好人。 你所做的一切坏事最初是一个坏的念头，萦绕在你脑中，直到最后实施。 同样，做一件好的事情也是一样道理——内在的自我是你成功果实赖以生长的土壤。 但是所有人都应该知道，所有人却都不能接受的事实是：「没有最后的果实，你就什么都不是」 比如你内心非常同情穷人。很伟大。 这会让你最后做什么实事么？ 你听到你社区里一些悲剧发生后，你会说「这些不幸的孩子啊，让他们知道我在内心同情他们」吗？ 你要这么说我就只好说「fuck you」——给我去真正帮助他们才是真的。 数以千万的人看了那段 Kony 视频（译注：2012 年 Youtube 上很有争议的关于非洲儿童的视频）， 所有看过的人都「在心里同情他们」。 那么这么强大的同情给儿童们带来了什么呢？屁都没有！ 每天有非洲的儿童死于非命，因为数以百万的我们对自己说关心和行动一样重要。 这是我们内心的一种心理机制，控制着我们大脑里犯懒的那一部分，让我们不断逃避真正去做实事。 有多少人此刻正在想：「她（他）如果知道我是多么有趣的人，一定会爱上我。」 真的吗？你那些有趣的想法有多少让世人知道了呢？ 如果你的心上人有一个隐藏摄像机跟着你拍一个月，他们会被录影的内容打动吗？ 记住，人们不会读心术，他们只会观察你的行动。 我希望你做的，只不过是用你看别人的标准来看你自己罢了。 你有没有一个烦人的基督徒朋友给别人最大的帮助只不过是「我为你祈祷」？ 你觉得烦不烦？ 我这里还没涉及到祈祷是不是实际有用呢，他们提供的帮助不需要他们屁股离开沙发就可以做。 他们认为自己思想纯净，但是他们纯净的思想土壤有没有结出果实呢？ 他们自己应该比别人更清楚这点——因为我「土壤-果实」的比喻就是从圣经里拿来的。 圣经里耶稣曾经不止一次说过「人们是根据果实来评判一颗树的」。 当然，耶稣从来不会说「想继续留在这里工作，就给我搞定单子」， 但他说「凡不结好果实的树，都要砍下來，扔在火里。」 对以上这些话无动于衷的人，就如同电影里对 Baldwin 无动于衷的业务员一样。（未完） 1： 人的内心其实一直在拒斥进步人类的大脑是很神奇的。 但你会发现大脑在拒斥进步的时候运转得比做实事的时候还快。 你的意识会通过层层防御机制来排斥任何会让你改变现状的事情—— 问一下对任何事物有瘾头的人就知道了。 所以，到现在，你们中的许多人一边读这篇文章，一边会感觉到大脑在不断提供排斥这篇文章的理由。 从经验上说，这些想法通常是： 有意将任何批评理解为侮辱 他凭什么说我又懒又没用？一个善良的人从来不会这样对我说话！ 作者写这些东西只不过是想显示自己有多么优越，让我这个loser对自己生活不满罢了！ 等我回复更损人的话给你！ 对人不对事 这人有什么资格告诉我怎么活？他自以为自己了不起吧？ 不过是网上的一个白痴写手罢了！我要去人肉他，看他有什么丑事可以抖出来。 这人真自以为是，让我作呕 只看语气，不看内容 我会仔细看你的文章，找出一句话，断章取义只讨论那个。 不断修饰你的过去 事情没那么糟糕。 确实我上个月还想自杀呢，但现在我感觉好多了！ 也许我只要继续做我现在做的事情，情况会好的。 让我继续给那个女神修电脑，女神总会到我身边的！ 认为改善生活的行为总会让你失去自我 哦，那么你是让我扔掉所有的漫画书。 天天去健身房 6 小时？ 因为除此之外我没选择了？」 当然还有其他的想法。 记住：【痛苦是会让人感到舒坦的】。 许多人选择拥抱痛苦。 幸福是需要努力的。 还有：勇气。 人们无法批评你根本没有去创造出来的东西，所以人们选择什么都不做来避免批评。 人们很容易双手一叉裤袋批评别人的工作。 「这个电影很傻」， 「这对父母的小孩很皮」， 「那对情侣的感情很糟糕」， 「那个暴发户不学无术」， 「这个餐厅糟透了」， 「本文作者是个白痴」， 我倒不如留一条损的回复让网站开除他——「瞧，我这不「创造」了一些东西么？」 哦，是啊，我忘记提醒你了。 不论你尝试建造或者创造什么东西——诗歌也好，新的技术也好，或者新的感情也好—— 你会立刻发现自己身边多了很多批评家。 这些批评家也许不会当你面损你，但是他们确实在挖苦你： 你的酒鬼朋友不希望你清醒，你肥胖的朋友不希望你苗条，你无业的朋友不希望看到你开始新的职业。 记住，他们不过在表达他们对生活的恐惧罢了，批评别人的工作是自己不作为的另一个理由。 「为什么我要创造什么东西呢，你看别人做的东西都糟透了！」 「我想写小说，不过我要等时机，我可不想写出暮光那样肤浅的东西」。 只要他们永远不动手去做事情，事情就永远是完美的。 或者他们如果真的着手做事情了，他们会故意不努力，让别人认为事情做不好是因为他们不在状态， 「他们真正的潜力是无穷的」，不是你看到的狗屎一样的产品。 往下翻读一下本文的回复——那些很极端的回复，永远都是「Cracked应该炒了这个作者」 「这个自负的白痴应该停止写作」。 所有一切的负面评论潜台词永远都是 「停止创作，如果换我来创作绝对比这个好千倍，你现在得到那么多人气让我自己很没面子。」 不要成为上述的那种人。 如果你是那种人，请不要继续成为那样的人。 这正是人们为什么不喜欢你的原因，这正是你恨自己的原因。 所以，我有个建议：给自己定一个期限，2013 年底，或者从你读本文之后的一年。 当别人跟你说「我的新年计划是减肥15磅」的时候， 我说咱们应该努力去做任何一件事情—— 学习新的技能直到足够有用为止，或者随便选一件事情：学空手道，学跳舞，学陶艺，做一个鸟屋，学习按摩，学一门语言，甚至拍一部A pian，做蝙蝠侠打击犯罪…… 关键在于：我不希望你把眼光放在某个过高的目标上，我希望你专注于获得一样新的， 【对其他人有用】的技能和经验。 「我没钱参加烹饪班」。那就 TMD 给我在 Google 上搜索：「如何烹饪」。 我的天，拜托你戒掉这些借口，否则这些借口就要你命了。 （You have to kill those excuses, or they will kill you） （要么你干掉那些借口，要么让那些借口干掉你） （完） 继续阅读关于 屌丝 哲理 的文章","link":"/2020/01/14/harsh-truths-that-will-make-you-a-better-person/"},{"title":"Java中的重载和重写","text":"一、重载(Overlording)1.概念：对于同一个类，如果这个类里面有两个或者多个重名的方法，但是方法的参数个数、类型、顺序至少有一个不一样，这时候局构成方法重载2.说明：方法重载必须要有相同的方法名，不同的参数个数或者顺序或者类型，返回值和访问修饰符、以及抛出的异常可以相同也可以不同。3.作用：方法重载是一个类里面的多态性的表现，重载可以根据传入的参数不同，决定具体调用那个函数，对不同数据类型的的数据实现相似的操作，提高了函数的灵活性。二、重写(Overriding)1.概念：当一个子类继承一父类，而子类中的方法与父类中的方法的名称，参数个数、类型都完全一致时，就称子类中的这个方法重写了父类中的方法。2.说明：重写必须是出现在继承关系中，子类重写父类中的方法，要求方法名、参数列表必须相同。子类的访问修饰符必须大于父类的否则编译会报错，返回类型必须要比父类的要小。重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查性异常（父类的异常宽泛性比子类的广）。3.作用：重写是父类、子类之间多态性的一种表现，重写可以增强父类中的方法","link":"/2017/12/13/java-overlording-overriding/"},{"title":"理解Java动态代理和CGLIB代理","text":"动态代理在Java中有着广泛的应用，比如Spring AOP，Hibernate数据查询、测试框架的后端mock、RPC，Java注解对象获取等。静态代理的代理关系在编译时就确定了，而动态代理的代理关系是在编译期确定的。静态代理实现简单，适合于代理类较少且确定的情况，而动态代理则给我们提供了更大的灵活性。今天我们来探讨Java中两种常见的动态代理方式：JDK原生动态代理和CGLIB动态代理。 JDK原生动态代理先从直观的示例说起，假设我们有一个接口Hello和一个简单实现HelloImp： 1234567891011// 接口interface Hello{ String sayHello(String str);}// 实现class HelloImp implements Hello{ @Override public String sayHello(String str) { return \"HelloImp: \" + str; }} 这是Java种再常见不过的场景，使用接口制定协议，然后用不同的实现来实现具体行为。假设你已经拿到上述类库，如果我们想通过日志记录对sayHello()的调用，使用静态代理可以这样做： 12345678910// 静态代理方式class StaticProxiedHello implements Hello{ ... private Hello hello = new HelloImp(); @Override public String sayHello(String str) { logger.info(\"You said: \" + str); return hello.sayHello(str); }} 上例中静态代理类StaticProxiedHello作为HelloImp的代理，实现了相同的Hello接口。用Java动态代理可以这样做： 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。 然后在需要使用Hello的时候，通过JDK动态代理获取Hello的代理对象。 12345678910111213141516171819202122// Java Proxy// 1. 首先实现一个InvocationHandler，方法调用会被转发到该类的invoke()方法。class LogInvocationHandler implements InvocationHandler{ ... private Hello hello; public LogInvocationHandler(Hello hello) { this.hello = hello; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { if(\"sayHello\".equals(method.getName())) { logger.info(\"You said: \" + Arrays.toString(args)); } return method.invoke(hello, args); }}// 2. 然后在需要使用Hello的时候，通过JDK动态代理获取Hello的代理对象。Hello hello = (Hello)Proxy.newProxyInstance( getClass().getClassLoader(), // 1. 类加载器 new Class&lt;?&gt;[] {Hello.class}, // 2. 代理需要实现的接口，可以有多个 new LogInvocationHandler(new HelloImp()));// 3. 方法调用的实际处理者System.out.println(hello.sayHello(\"I love you!\")); 运行上述代码输出结果： 12日志信息: You said: [I love you!]HelloImp: I love you! 上述代码的关键是 1Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler) 方法，该方法会根据指定的参数动态创建代理对象。三个参数的意义如下： loader，指定代理对象的类加载器； interfaces，代理对象需要实现的接口，可以同时指定多个接口； handler，方法调用的实际处理者，代理对象的方法调用都会转发到这里（*注意1）。newProxyInstance()会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给InvocationHandler.invoke()方法。理解上述代码需要对Java反射机制有一定了解。动态代理神奇的地方 就是： 代理对象是在程序运行时产生的，而不是编译期； 对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法，在invoke()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；之后我们通过某种方式执行真正的方法体，示例中通过反射调用了Hello对象的相应方法，还可以通过RPC调用远程方法。 注意1：对于从Object中继承的方法，JDK Proxy会把hashCode()、equals()、toString()这三个非接口方法转发给InvocationHandler，其余的Object方法则不会转发。详见JDK Proxy官方文档。 如果对JDK代理后的对象类型进行深挖，可以看到如下信息： 123456# Hello代理对象的类型信息class=class jdkproxy.$Proxy0superClass=class java.lang.reflect.Proxyinterfaces: interface jdkproxy.HelloinvocationHandler=jdkproxy.LogInvocationHandler@a09ee92 代理对象的类型是jdkproxy.$Proxy0，这是个动态生成的类型，类名是形如$ProxyN的形式；父类是java.lang.reflect.Proxy，所有的JDK动态代理都会继承这个类；同时实现了Hello接口，也就是我们接口列表中指定的那些接口。 如果你还对jdkproxy.$Proxy0具体实现感兴趣，它大致长这个样子： 1234567891011121314151617// JDK代理类具体实现public final class $Proxy0 extends Proxy implements Hello{ ... public $Proxy0(InvocationHandler invocationhandler) { super(invocationhandler); } ... @Override public final String sayHello(String str){ ... return super.h.invoke(this, m3, new Object[] {str});// 将方法调用转发给invocationhandler ... } ...} 这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。更多详情，可参考BrightLoong的Java静态代理&amp;动态代理笔记 Java动态代理为我们提供了非常灵活的代理机制，但Java动态代理是基于接口的，如果对象没有实现接口我们该如何代理呢？CGLIB登场。 CGLIB动态代理CGLIB(Code Generation Library)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理。 来看示例，假设我们有一个没有实现任何接口的类HelloConcrete： 12345public class HelloConcrete { public String sayHello(String str) { return \"HelloConcrete: \" + str; }} 因为没有实现接口该类无法使用JDK代理，通过CGLIB代理实现如下： 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。 1234567891011121314151617// CGLIB动态代理// 1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。class MyMethodInterceptor implements MethodInterceptor{ ... @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { logger.info(\"You said: \" + Arrays.toString(args)); return proxy.invokeSuper(obj, args); }}// 2. 然后在需要使用HelloConcrete的时候，通过CGLIB动态代理获取代理对象。Enhancer enhancer = new Enhancer();enhancer.setSuperclass(HelloConcrete.class);enhancer.setCallback(new MyMethodInterceptor());HelloConcrete hello = (HelloConcrete)enhancer.create();System.out.println(hello.sayHello(\"I love you!\")); 运行上述代码输出结果： 12日志信息: You said: [I love you!]HelloConcrete: I love you! 上述代码中，我们通过CGLIB的Enhancer来指定要代理的目标对象、实际处理代理逻辑的对象，最终通过调用create()方法得到代理对象，对这个对象所有非final方法的调用都会转发给MethodInterceptor.intercept()方法，在intercept()方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等；通过调用MethodProxy.invokeSuper()方法，我们将调用转发给原始对象，具体到本例，就是HelloConcrete的具体方法。CGLIG中MethodInterceptor的作用跟JDK代理中的InvocationHandler很类似，都是方法调用的中转站。 注意：对于从Object中继承的方法，CGLIB代理也会进行代理，如hashCode()、equals()、toString()等，但是getClass()、wait()等方法不会，因为它是final方法，CGLIB无法代理。 如果对CGLIB代理之后的对象类型进行深挖，可以看到如下信息： 123456# HelloConcrete代理对象的类型信息class=class cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52superClass=class lh.HelloConcreteinterfaces: interface net.sf.cglib.proxy.FactoryinvocationHandler=not java proxy class 我们看到使用CGLIB代理之后的对象类型是cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52，这是CGLIB动态生成的类型；父类是HelloConcrete，印证了CGLIB是通过继承实现代理；同时实现了net.sf.cglib.proxy.Factory接口，这个接口是CGLIB自己加入的，包含一些工具方法。 注意，既然是继承就不得不考虑final的问题。我们知道final类型不能有子类，所以CGLIB不能代理final类型，遇到这种情况会抛出类似如下异常： 1java.lang.IllegalArgumentException: Cannot subclass final class cglib.HelloConcrete 同样的，final方法是不能重载的，所以也不能通过CGLIB代理，遇到这种情况不会抛异常，而是会跳过final方法只代理其他方法。 如果你还对代理类cglib.HelloConcrete$$EnhancerByCGLIB$$e3734e52具体实现感兴趣，它大致长这个样子： 123456789101112131415161718192021222324// CGLIB代理类具体实现public class HelloConcrete$$EnhancerByCGLIB$$e3734e52 extends HelloConcrete implements Factory{ ... private MethodInterceptor CGLIB$CALLBACK_0; // ~~ ... public final String sayHello(String paramString) { ... MethodInterceptor tmp17_14 = CGLIB$CALLBACK_0; if (tmp17_14 != null) { // 将请求转发给MethodInterceptor.intercept()方法。 return (String)tmp17_14.intercept(this, CGLIB$sayHello$0$Method, new Object[] { paramString }, CGLIB$sayHello$0$Proxy); } return super.sayHello(paramString); } ...} 上述代码我们看到，当调用代理对象的sayHello()方法时，首先会尝试转发给MethodInterceptor.intercept()方法，如果没有MethodInterceptor就执行父类的sayHello()。这些逻辑没什么复杂之处，但是他们是在运行时动态产生的，无需我们手动编写。如何获取CGLIB代理类字节码可参考Access the generated byte[] array directly。 更多关于CGLIB的介绍可以参考Rafael Winterhalter的cglib: The missing manual，一篇很深入的文章。 结语本文介绍了Java两种常见动态代理机制的用法和原理，JDK原生动态代理是Java原生支持的，不需要任何外部依赖，但是它只能基于接口进行代理；CGLIB通过继承的方式进行代理，无论目标对象有没有实现接口都可以代理，但是无法处理final的情况。 动态代理是Spring AOP(Aspect Orient Programming, 面向切面编程)的实现方式，了解动态代理原理，对理解Spring AOP大有帮助。","link":"/2019/12/11/java-dynamic-proxy-and-cglib/"},{"title":"如何在Java代码中去掉烦人的“!=null”","text":"source：Java知音https://mp.weixin.qq.com/s/-u1T6qRtTnizkTZSFfsICw 问题 为了避免空指针调用，我们经常会看到这样的语句 123if (someobject != null) { someobject.doCalc();} 最终，项目中会存在大量判空代码，多么丑陋繁冗！如何避免这种情况？我们是否滥用了判空呢？ 回答 这是初、中级程序猿经常会遇到的问题。他们总喜欢在方法中返回null，因此，在调用这些方法时，也不得不去判空。另外，也许受此习惯影响，他们总潜意识地认为，所有的返回都是不可信任的，为了保护自己程序，就加了大量的判空。 吐槽完毕，回到这个题目本身，进行判空前，请区分以下两种情况： null 是一个有效有意义的返回值(Where null is a valid response in terms of the contract; and)null是无效有误的(Where it isn’t a valid response.)你可能还不明白这两句话的意思，不急，继续往下看，接下来将详细讨论这两种情况 先说第2种情况 null就是一个不合理的参数，就应该明确地中断程序，往外抛错误。这种情况常见于api方法。例如你开发了一个接口，id是一个必选的参数，如果调用方没传这个参数给你，当然不行。你要感知到这个情况，告诉调用方“嘿，哥们，你传个null给我做甚”。 相对于判空语句，更好的检查方式有两个 assert语句，你可以把错误原因放到assert的参数中，这样不仅能保护你的程序不往下走，而且还能把错误原因返回给调用方，岂不是一举两得。（原文介绍了assert的使用，这里省略）也可以直接抛出空指针异常。上面说了，此时null是个不合理的参数，有问题就是有问题，就应该大大方方往外抛。第1种情况会更复杂一些。 这种情况下，null是个”看上去“合理的值，例如，我查询数据库，某个查询条件下，就是没有对应值，此时null算是表达了“空”的概念。 这里给一些实践建议： 假如方法的返回类型是collections，当返回结果是空时，你可以返回一个空的collections（empty list),而不要返回null.这样调用侧就能大胆地处理这个返回，例如调用侧拿到返回后，可以直接print list.size()，又无需担心空指针问题。（什么？想调用这个方法时，不记得之前实现该方法有没按照这个原则？所以说，代码习惯很重要！如果你养成习惯，都是这样写代码（返回空collections而不返回null)，你调用自己写的方法时，就能大胆地忽略判空）返回类型不是collections，又怎么办呢？ 那就返回一个空对象（而非null对象），下面举个“栗子”，假设有如下代码 123456public interface Action { void doSomething();}public interface Parser { Action findAction(String userInput);} 其中，Parse有一个接口FindAction，这个接口会依据用户的输入，找到并执行对应的动作。假如用户输入不对，可能就找不到对应的动作（Action），因此findAction就会返回null，接下来action调用doSomething方法时，就会出现空指针。 解决这个问题的一个方式，就是使用Null Object pattern（空对象模式） 我们来改造一下 类定义如下，这样定义findAction方法后，确保无论用户输入什么，都不会返回null对象： 123456789101112public class MyParser implements Parser { private static Action DO_NOTHING = new Action() { public void doSomething() { /* do nothing */ } }; public Action findAction(String userInput) { // ... if ( /* we can't find any actions */ ) { return DO_NOTHING; } }} 对比下面两份调用实例 1.冗余: 每获取一个对象，就判一次空 1234567891011Parser parser = ParserFactory.getParser();if (parser == null) { // now what? // this would be an example of where null isn't (or shouldn't be) a valid response}Action action = parser.findAction(someInput);if (action == null) { // do nothing} else { action.doSomething();} 2.精简 1ParserFactory.getParser().findAction(someInput).doSomething(); 因为无论什么情况，都不会返回空对象，因此通过findAction拿到action后，可以放心地调用action的方法。扩展一下：Java:如何更优雅的处理空值？ 其他回答精选： 如果要用equal方法，请用object&lt;不可能为空&gt;.equal(object&lt;可能为空&gt;)) 例如： 使用 “bar”.equals(foo)而不是 foo.equals(“bar”)Java8或者guava lib中，提供了Optional类，这是一个元素容器，通过它来封装对象，可以减少判空。不过代码量还是不少。不爽。 如果你想返回null，请停下来想一想，这个地方是否更应该抛出一个异常。","link":"/2020/04/11/java-null-check/"},{"title":"js倒计时刷新页面","text":"1，reload 方法，该方法强迫浏览器刷新当前页面。语法：location.reload([bForceGet]) &nbsp;&nbsp;参数： bForceGet， 可选参数， 默认为 false，从客户端缓存里取当前页。true, 则以 GET 方式，从服务端取最新的页面, 相当于客户端点击 F5(&quot;刷新&quot;)2，replace 方法，该方法通过指定URL替换当前缓存在历史里（客户端）的项目，因此当使用replace方法之后，你不能通过“前进”和“后退”来访问已经被替换的URL。语法： location.replace(URL) &nbsp;&nbsp;通常使用： location.reload() 或者是 history.go(0) 来做。此方法类似客户端点F5刷新页面，所以页面method=&quot;post&quot;时，会出现&quot;网页过期&quot;的提示。因为Session的安全保护机制。当调用 location.reload() 方法时， aspx页面此时在服务端内存里已经存在， 因此必定是 IsPostback 的。如果有这种应用： 需要重新加载该页面，也就是说期望页面能够在服务端重新被创建，期望是 Not IsPostback 的。这里，location.replace() 就可以完成此任务。被replace的页面每次都在服务端重新生成。代码： location.replace(location.href);返回并刷新页面：location.replace(document.referrer);document.referrer //前一个页面的URL不要用 history.go(-1)，或 history.back();来返回并刷新页面，这两种方法不会刷新页面。Javascript刷新页面的几种方法：1，history.go(0)&nbsp; 2，location.reload()&nbsp; 3，location=location&nbsp; 4，location.assign(location)&nbsp; 5，document.execCommand('Refresh')&nbsp; 6，window.navigate(location)&nbsp; 7，location.replace(location)&nbsp; 8，document.URL=location.href自动刷新页面的方法:1，页面自动刷新：把如下代码加入&lt;head&gt;区域中&lt;meta&nbsp;http-equiv=&quot;refresh&quot;&nbsp;content=&quot;20&quot;&gt;其中20指每隔20秒刷新一次页面.2，页面自动跳转：把如下代码加入&lt;head&gt;区域中&lt;meta&nbsp;http-equiv=&quot;refresh&quot;&nbsp;content=&quot;20;url=http://www.hr2812.cn&quot;&gt;其中20指隔20秒后跳转到http://www.hr2812.cn页面 3，页面自动刷新js版&lt;script&nbsp;language=&quot;JavaScript&quot;&gt; function&nbsp;myrefresh() { &nbsp;&nbsp;&nbsp;window.location.reload(); } setTimeout('myrefresh()',1000);&nbsp;//指定1秒刷新一次 &lt;/script&gt;4，JS刷新框架的脚本语句//刷新包含该框架的页面用&nbsp;&nbsp;&nbsp; &lt;script&nbsp;language=JavaScript&gt; &nbsp;&nbsp;&nbsp;parent.location.reload(); &lt;/script&gt; //子窗口刷新父窗口 &lt;script&nbsp;language=JavaScript&gt; &nbsp;&nbsp;&nbsp;&nbsp;self.opener.location.reload(); &lt;/script&gt; ( 或 &lt;a&nbsp;href=&quot;javascript:opener.location.reload()&quot;&gt;刷新&lt;/a&gt;&nbsp;&nbsp;&nbsp;) //刷新另一个框架的页面用&nbsp;&nbsp;&nbsp; &lt;script&nbsp;language=JavaScript&gt; &nbsp;&nbsp;&nbsp;parent.另一FrameID.location.reload(); &lt;/script&gt;如果想关闭窗口时刷新或想开窗时刷新，在&lt;body&gt;中调用以下语句即可。&lt;body&nbsp;onload=&quot;opener.location.reload()&quot;&gt;&nbsp;开窗时刷新 &lt;body&nbsp;onUnload=&quot;opener.location.reload()&quot;&gt;&nbsp;关闭时刷新 &lt;script&nbsp;language=&quot;javascript&quot;&gt; window.opener.document.location.reload() &lt;/script&gt;一、先来看一个简单的例子：&nbsp;下面以三个页面分别命名为frame.html、top.html、bottom.html为例来具体说明如何做。&nbsp;frame.html 由上(top.html)下(bottom.html)两个页面组成，代码如下：&lt;!DOCTYPE&nbsp;HTML&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;HTML&nbsp;4.0&nbsp;Transitional//EN&quot;&gt;&nbsp; &lt;HTML&gt;&nbsp; &lt;HEAD&gt;&nbsp; &lt;TITLE&gt;&nbsp;frame&nbsp;&lt;/TITLE&gt;&nbsp; &lt;/HEAD&gt;&nbsp; &lt;frameset&nbsp;rows=&quot;50%,50%&quot;&gt;&nbsp; &lt;frame&nbsp;name=top&nbsp;src=&quot;top.html&quot;&gt;&nbsp; &lt;frame&nbsp;name=bottom&nbsp;src=&quot;bottom.html&quot;&gt;&nbsp; &lt;/frameset&gt;&nbsp; &lt;/HTML&gt;现在假设top.html (即上面的页面) 有七个button来实现对bottom.html (即下面的页面) 的刷新，可以用以下七种语句，哪个好用自己看着办了。&nbsp;top.html 页面的代码如下：&nbsp;&lt;!DOCTYPE&nbsp;HTML&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;HTML&nbsp;4.0&nbsp;Transitional//EN&quot;&gt;&nbsp; &lt;HTML&gt;&nbsp; &lt;HEAD&gt;&nbsp; &lt;TITLE&gt;&nbsp;top.html&nbsp;&lt;/TITLE&gt;&nbsp; &lt;/HEAD&gt;&nbsp; &lt;BODY&gt;&nbsp; &lt;input&nbsp;type=button&nbsp;value=&quot;刷新1&quot;&nbsp;onclick=&quot;window.parent.frames[1].location.reload()&quot;&gt;&lt;br&gt;&nbsp; &lt;input&nbsp;type=button&nbsp;value=&quot;刷新2&quot;&nbsp;onclick=&quot;window.parent.frames.bottom.location.reload()&quot;&gt;&lt;br&gt;&nbsp; &lt;input&nbsp;type=button&nbsp;value=&quot;刷新3&quot;&nbsp;onclick=&quot;window.parent.frames['bottom'].location.reload()&quot;&gt;&lt;br&gt;&nbsp; &lt;input&nbsp;type=button&nbsp;value=&quot;刷新4&quot;&nbsp;onclick=&quot;window.parent.frames.item(1).location.reload()&quot;&gt;&lt;br&gt;&nbsp; &lt;input&nbsp;type=button&nbsp;value=&quot;刷新5&quot;&nbsp;onclick=&quot;window.parent.frames.item('bottom').location.reload()&quot;&gt;&lt;br&gt;&nbsp; &lt;input&nbsp;type=button&nbsp;value=&quot;刷新6&quot;&nbsp;onclick=&quot;window.parent.bottom.location.reload()&quot;&gt;&lt;br&gt;&nbsp; &lt;input&nbsp;type=button&nbsp;value=&quot;刷新7&quot;&nbsp;onclick=&quot;window.parent['bottom'].location.reload()&quot;&gt;&lt;br&gt;&nbsp; &lt;/BODY&gt;&nbsp; &lt;/HTML&gt;下面是bottom.html页面源代码，为了证明下方页面的确被刷新了，在装载完页面弹出一个对话框。&nbsp;&lt;!DOCTYPE&nbsp;HTML&nbsp;PUBLIC&nbsp;&quot;-//W3C//DTD&nbsp;HTML&nbsp;4.0&nbsp;Transitional//EN&quot;&gt;&nbsp; &lt;HTML&gt;&nbsp; &lt;HEAD&gt;&nbsp; &lt;TITLE&gt;&nbsp;bottom.html&nbsp;&lt;/TITLE&gt;&nbsp; &lt;/HEAD&gt;&nbsp; &lt;BODY&nbsp;onload=&quot;alert('我被加载了！')&quot;&gt;&nbsp; &lt;h1&gt;This&nbsp;is&nbsp;the&nbsp;content&nbsp;in&nbsp;bottom.html.&lt;/h1&gt;&nbsp; &lt;/BODY&gt;&nbsp; &lt;/HTML&gt;解释一下：1.window指代的是当前页面，例如对于此例它指的是top.html页面。&nbsp; 2.parent指的是当前页面的父页面，也就是包含它的框架页面。例如对于此例它指的是framedemo.html。&nbsp; 3.frames是window对象，是一个数组。代表着该框架内所有子页面。&nbsp; 4.item是方法。返回数组里面的元素。&nbsp; 5.如果子页面也是个框架页面，里面还是其它的子页面，那么上面的有些方法可能不行。&nbsp; 附：&nbsp; Javascript刷新页面的几种方法：&nbsp; 1&nbsp;history.go(0)&nbsp; 2&nbsp;location.reload()&nbsp; 3&nbsp;location=location&nbsp; 4&nbsp;location.assign(location)&nbsp; 5&nbsp;document.execCommand('Refresh')&nbsp; 6&nbsp;window.navigate(location)&nbsp; 7&nbsp;location.replace(location)&nbsp; 8&nbsp;document.URL=location.href二、自动刷新页面&nbsp;1.页面自动刷新：把如下代码加入&lt;head&gt;区域中&nbsp;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20&quot;&gt;&nbsp;其中20指每隔20秒刷新一次页面.&nbsp;2.页面自动跳转：把如下代码加入&lt;head&gt;区域中&nbsp;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;20;url=http://www.hr2812.cn&quot;&gt;&nbsp;其中20指隔20秒后跳转到http://www.hr2812.cn页面&nbsp;3.页面自动刷新js版&nbsp;&lt;script&nbsp;language=&quot;JavaScript&quot;&gt;&nbsp; function&nbsp;myrefresh()&nbsp; {&nbsp; window.location.reload();&nbsp; }&nbsp; setTimeout('myrefresh()',1000);&nbsp;//指定1秒刷新一次&nbsp; &lt;/script&gt;三、java在写Servler,Action等程序时，要操作返回页面的话（如谈出了窗口，操作完成以后，关闭当前页面，刷新父页面）&nbsp;复制代码 代码如下:1&nbsp;PrintWriter&nbsp;out&nbsp;=&nbsp;response.getWriter();&nbsp; 2&nbsp;out.write(&quot;&lt;script&nbsp;type=\\&quot;text/javascript\\&quot;&gt;&quot;);&nbsp; 3&nbsp;////子窗口刷新父窗口&nbsp; 4&nbsp;out.write(&quot;self.opener.location.reload();&quot;);&nbsp; 5&nbsp;//关闭窗口&nbsp; 6&nbsp;out.write(&quot;window.opener=null;&quot;);&nbsp; 7&nbsp;out.write(&quot;window.close();&quot;);&nbsp; 8&nbsp;out.write(&quot;&lt;/script&gt;&quot;);四、JS刷新框架的脚本语句&nbsp;1.如何刷新包含该框架的页面用&nbsp;&lt;script&nbsp;language=JavaScript&gt;&nbsp; parent.location.reload();&nbsp; &lt;/script&gt;2.子窗口刷新父窗口&lt;script&nbsp;language=JavaScript&gt;&nbsp; self.opener.location.reload();&nbsp; &lt;/script&gt;3.如何刷新另一个框架的页面用 （上面的实例以说明了）语句1.&nbsp;window.parent.frames[1].location.reload();&nbsp; 语句2.&nbsp;window.parent.frames.bottom.location.reload();&nbsp; 语句3.&nbsp;window.parent.frames[&quot;bottom&quot;].location.reload();&nbsp; 语句4.&nbsp;window.parent.frames.item(1).location.reload();&nbsp; 语句5.&nbsp;window.parent.frames.item('bottom').location.reload();&nbsp; 语句6.&nbsp;window.parent.bottom.location.reload();&nbsp; 语句7.&nbsp;window.parent['bottom'].location.reload();4.如果想关闭窗口时刷新或者想开窗时刷新的话，在&lt;body&gt;中调用以下语句即可。&lt;body&nbsp;onload=&quot;opener.location.reload()&quot;&gt;&nbsp; 开窗时刷新&nbsp; &lt;body&nbsp;onUnload=&quot;opener.location.reload()&quot;&gt;&nbsp; 关闭时刷新&nbsp; &lt;script&nbsp;language=&quot;javascript&quot;&gt;&nbsp; window.opener.document.location.reload()&nbsp; &lt;/script&gt;","link":"/2017/12/05/javascript-countdown-3-method/"},{"title":"json问题","text":"刚才的一个问题，搞了一个多小时。。 页面想controller请求一个RSA的privateKey用于登录加密，之前我是成功获得过的。然后换了毕业设计这个项目，直接把相关代码复制过来，就出现加密失败的问题。原因：之前用的SpringMVC框架，在返回json数据时用了@ResponseBody注解，这样页面就能直接拿到json格式的字符串。而毕业设计中用的struts2，把key转成json字符串，用response返回的。response.setContentType(&quot;application/json;charset=utf-8&quot;);我之前写的是“text/html”改成这个就好了，前端用的$.post没有设置ajax中的datatype，，所以才会搞了这么久。主要是我以为是RSAUtils里面的问题，这个就误导了我。。","link":"/2018/03/18/json-little-problem/"},{"title":"简直不敢想，我竟然把压缩20M文件从30秒优化到1秒...","text":"有一个需求需要将前端传过来的10张照片，然后后端进行处理以后压缩成一个压缩包通过网络流传输出去。之前没有接触过用Java压缩文件的，所以就直接上网找了一个例子改了一下用了，改完以后也能使用，但是随着前端所传图片的大小越来越大的时候，耗费的时间也在急剧增加，最后测了一下压缩20M的文件竟然需要30秒的时间。 压缩文件的代码如下。 1234567891011121314151617181920 public static void zipFileNoBuffer() { File zipFile = new File(ZIP_FILE); try (ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile))) { //开始时间 long beginTime = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) { try (InputStream input = new FileInputStream(JPG_FILE)) { zipOut.putNextEntry(new ZipEntry(FILE_NAME + i)); int temp = 0; while ((temp = input.read()) != -1) { zipOut.write(temp); } } } printInfo(beginTime); } catch (Exception e) { e.printStackTrace(); }} 这里找了一张2M大小的图片，并且循环十次进行测试。打印的结果如下，时间大概是30秒。 12fileSize:20Mconsum time:29599 第一次优化过程-从30秒到2秒进行优化首先想到的是利用缓冲区BufferInputStream。在FileInputStream中read()方法每次只读取一个字节。源码中也有说明。 123456789/** * Reads a byte of data from this input stream. This method blocks * if no input is yet available. * * @return the next byte of data, or &lt;code&gt;-1&lt;/code&gt; if the end of the * file is reached. * @exception IOException if an I/O error occurs. */public native int read() throws IOException; 这是一个调用本地方法与原生操作系统进行交互，从磁盘中读取数据。每读取一个字节的数据就调用一次本地方法与操作系统交互，是非常耗时的。例如我们现在有30000个字节的数据，如果使用FileInputStream那么就需要调用30000次的本地方法来获取这些数据，而如果使用缓冲区的话（这里假设初始的缓冲区大小足够放下30000字节的数据）那么只需要调用一次就行。因为缓冲区在第一次调用read()方法的时候会直接从磁盘中将数据直接读取到内存中。随后再一个字节一个字节的慢慢返回。BufferedInputStream内部封装了一个byte数组用于存放数据，默认大小是8192优化过后的代码如下 1234567891011121314151617181920 public static void zipFileBuffer() { File zipFile = new File(ZIP_FILE); try (ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile)); BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(zipOut)) { //开始时间 long beginTime = System.currentTimeMillis(); for (int i = 0; i &lt; 10; i++) { try (BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(JPG_FILE))) { zipOut.putNextEntry(new ZipEntry(FILE_NAME + i)); int temp = 0; while ((temp = bufferedInputStream.read()) != -1) { bufferedOutputStream.write(temp); } } } printInfo(beginTime); } catch (Exception e) { e.printStackTrace(); }} 输出——BufferfileSize:20Mconsum time:1808 可以看到相比较于第一次使用FileInputStream效率已经提升了许多了 第二次优化过程-从2秒到1秒使用缓冲区buffer的话已经是满足了我的需求了，但是秉着学以致用的想法，就想着用NIO中知识进行优化一下。 使用Channel 为什么要用Channel呢？因为在NIO中新出了Channel和ByteBuffer。正是因为它们的结构更加符合操作系统执行I/O的方式，所以其速度相比较于传统IO而言速度有了显著的提高。Channel就像一个包含着煤矿的矿藏，而ByteBuffer则是派送到矿藏的卡车。也就是说我们与数据的交互都是与ByteBuffer的交互。 在NIO中能够产生FileChannel的有三个类。分别是FileInputStream、FileOutputStream、以及既能读又能写的RandomAccessFile。 源码如下 12345678910111213141516 public static void zipFileChannel() { //开始时间 long beginTime = System.currentTimeMillis(); File zipFile = new File(ZIP_FILE); try (ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile)); WritableByteChannel writableByteChannel = Channels.newChannel(zipOut)) { for (int i = 0; i &lt; 10; i++) { try (FileChannel fileChannel = new FileInputStream(JPG_FILE).getChannel()) { zipOut.putNextEntry(new ZipEntry(i + SUFFIX_FILE)); fileChannel.transferTo(0, FILE_SIZE, writableByteChannel); } } printInfo(beginTime); } catch (Exception e) { e.printStackTrace(); }} 我们可以看到这里并没有使用ByteBuffer进行数据传输，而是使用了transferTo的方法。这个方法是将两个通道进行直连。 1234This method is potentially much more efficient than a simple loop* that reads from this channel and writes to the target channel. Many* operating systems can transfer bytes directly from the filesystem cache* to the target channel without actually copying them. 这是源码上的描述文字，大概意思就是使用transferTo的效率比循环一个Channel读取出来然后再循环写入另一个Channel好。操作系统能够直接传输字节从文件系统缓存到目标的Channel中，而不需要实际的copy阶段copy阶段就是从内核空间转到用户空间的一个过程可以看到速度相比较使用缓冲区已经有了一些的提高。 123------ChannelfileSize:20Mconsum time:1416 内核空间和用户空间那么为什么从内核空间转向用户空间这段过程会慢呢？首先我们需了解的是什么是内核空间和用户空间。在常用的操作系统中为了保护系统中的核心资源，于是将系统设计为四个区域，越往里权限越大，所以Ring0被称之为内核空间，用来访问一些关键性的资源。Ring3被称之为用户空间。 用户态、内核态：线程处于内核空间称之为内核态，线程处于用户空间属于用户态那么我们如果此时应用程序（应用程序是都属于用户态的）需要访问核心资源怎么办呢？那就需要调用内核中所暴露出的接口用以调用，称之为系统调用。例如此时我们应用程序需要访问磁盘上的文件。此时应用程序就会调用系统调用的接口open方法，然后内核去访问磁盘中的文件，将文件内容返回给应用程序。大致的流程如下 直接缓冲区和非直接缓冲区 既然我们要读取一个磁盘的文件，要废这么大的周折。有没有什么简单的方法能够使我们的应用直接操作磁盘文件，不需要内核进行中转呢？有，那就是建立直接缓冲区了。 非直接缓冲区：非直接缓冲区就是我们上面所讲内核态作为中间人，每次都需要内核在中间作为中转。 直接缓冲区：直接缓冲区不需要内核空间作为中转copy数据，而是直接在物理内存申请一块空间，这块空间映射到内核地址空间和用户地址空间，应用程序与磁盘之间数据的存取通过这块直接申请的物理内存进行交互。 既然直接缓冲区那么快，我们为什么不都用直接缓冲区呢？其实直接缓冲区有以下的缺点。直接缓冲区的缺点： 不安全消耗更多，因为它不是在JVM中直接开辟空间。这部分内存的回收只能依赖于垃圾回收机制，垃圾什么时候回收不受我们控制。数据写入物理内存缓冲区中，程序就丧失了对这些数据的管理，即什么时候这些数据被最终写入从磁盘只能由操作系统来决定，应用程序无法再干涉。综上所述，所以我们使用transferTo方法就是直接开辟了一段直接缓冲区。所以性能相比而言提高了许多 使用内存映射文件 NIO中新出的另一个特性就是内存映射文件，内存映射文件为什么速度快呢？其实原因和上面所讲的一样，也是在内存中开辟了一段直接缓冲区。与数据直接作交互。源码如下 12345678910111213141516171819202122 //Version 4 使用Map映射文件 public static void zipFileMap() { //开始时间 long beginTime = System.currentTimeMillis(); File zipFile = new File(ZIP_FILE); try (ZipOutputStream zipOut = new ZipOutputStream(new FileOutputStream(zipFile)); WritableByteChannel writableByteChannel = Channels.newChannel(zipOut)) { for (int i = 0; i &lt; 10; i++) { zipOut.putNextEntry(new ZipEntry(i + SUFFIX_FILE)); //内存中的映射文件 MappedByteBuffer mappedByteBuffer = new RandomAccessFile(JPG_FILE_PATH, \"r\").getChannel() .map(FileChannel.MapMode.READ_ONLY, 0, FILE_SIZE); writableByteChannel.write(mappedByteBuffer); } printInfo(beginTime); } catch (Exception e) { e.printStackTrace(); }} 打印如下 123---------MapfileSize:20Mconsum time:1305 可以看到速度和使用Channel的速度差不多的 使用Pipe Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。其中source通道用于读取数据，sink通道用于写入数据。可以看到源码中的介绍，大概意思就是写入线程会阻塞至有读线程从通道中读取数据。如果没有数据可读，读线程也会阻塞至写线程写入数据。直至通道关闭。 Whether or not a thread writing bytes to a pipe will block until another thread reads those bytes 我想要的效果是这样的。源码如下 1234567891011121314151617181920212223 //Version 5 使用Pip public static void zipFilePip() { long beginTime = System.currentTimeMillis(); try(WritableByteChannel out = Channels.newChannel(new FileOutputStream(ZIP_FILE))) { Pipe pipe = Pipe.open(); //异步任务 CompletableFuture.runAsync(()-&gt;runTask(pipe)); //获取读通道 ReadableByteChannel readableByteChannel = pipe.source(); ByteBuffer buffer = ByteBuffer.allocate(((int) FILE_SIZE)*10); while (readableByteChannel.read(buffer)&gt;= 0) { buffer.flip(); out.write(buffer); buffer.clear(); } }catch (Exception e){ e.printStackTrace(); } printInfo(beginTime);} 12345678910111213141516171819//异步任务public static void runTask(Pipe pipe) { try(ZipOutputStream zos = new ZipOutputStream(Channels.newOutputStream(pipe.sink())); WritableByteChannel out = Channels.newChannel(zos)) { System.out.println(\"Begin\"); for (int i = 0; i &lt; 10; i++) { zos.putNextEntry(new ZipEntry(i+SUFFIX_FILE)); FileChannel jpgChannel = new FileInputStream(new File(JPG_FILE_PATH)).getChannel(); jpgChannel.transferTo(0, FILE_SIZE, out); jpgChannel.close(); } }catch (Exception e){ e.printStackTrace(); }} 总结生活处处都需要学习，有时候只是一个简单的优化，可以让你深入学习到各种不同的知识。所以在学习中要不求甚解，不仅要知道这个知识也要了解为什么要这么做。知行合一：学习完一个知识要尽量应用一遍。这样才能记得牢靠。","link":"/2020/03/17/java-zip-file-optimize/"},{"title":"搬砖之路-前端学习的重要性","text":"前端的内容学起来真难 打开一个git上的项目，里面的代码看起来好费劲 要是对前端没一点了解的话 完全看不懂代码的意思 趁着自己还有兴趣 还是多学吧 &nbsp; 之前觉得看视频学得会很快 现在变得越来越浮躁了，根本不想看视频，直接看项目 那些东西又实在看不懂，就会变得很烦躁 想起大三的某个时间段，每天除了上课，剩下时间都会在寝室看视频，写代码 晚上到了八九点就去网吧玩几局LOL奖励自己 那段日子是真的很踏实、很开心 虽然学得很垃圾，也没写出什么 但也就那个时候，我开始想得更多 想起最最开始的时候，我甚至都不知道一个web应用是怎么由前端请求访问后端的 两年过去了 虽然我还是很垃圾 想起以前的自己的那个时候 &nbsp; 也许这条路，我只会混混日子，混口饭吃 但只要我还有一丝兴趣、喜欢 我就不会放弃 &nbsp; 碎觉。","link":"/2019/05/31/ku-bi-zhi-lu/"},{"title":"Mybatis学习笔记(转载)","text":"Mybatis技术内幕系列博客，从原理和源码角度，介绍了其内部实现细节，无论是写的好与不好，我确实是用心写了， 由于并不是介绍如何使用Mybatis的文章，所以，一些参数使用细节略掉了，我们的目标是介绍Mybatis的技术架构和重要组成部分，以及基本运行原理。博客写的很辛苦，但是写出来却不一定好看，所谓开始很兴奋，过程很痛苦，结束很遗憾。要求不高，只要读者能从系列博客中，学习到一点其他博客所没有的技术点，作为作者，我就很欣慰了，我也读别人写的博客，通常对自己当前研究的技术，是很有帮助的。尽管还有很多可写的内容，但是，我认为再写下去已经没有意义，任何其他小的功能点，都是在已经介绍的基本框架和基本原理下运行的，只有结束，才能有新的开始。写博客也积攒了一些经验，源码多了感觉就是复制黏贴，源码少了又觉得是空谈原理，将来再写博客，我希望是“精炼博文”，好读好懂美观读起来又不累，希望自己能再写一部开源分布式框架原理系列博客。有胆就来，我出几道Mybatis面试题，看你能回答上来几道（都是我出的，可不是网上找的）。1、#{}和${}的区别是什么？注：这道题是面试官面试我同事的。答：${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。2、Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？注：这道题是京东面试官面试我时问的。答：还有很多其他的标签，&lt;resultMap&gt;、&lt;parameterMap&gt;、&lt;sql&gt;、&lt;include&gt;、&lt;selectKey&gt;，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中&lt;sql&gt;为sql片段标签，通过&lt;include&gt;标签引入sql片段，&lt;selectKey&gt;为不支持自增的主键生成策略标签。3、最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？注：这道题也是京东面试官面试我时问的。答：Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id =&nbsp;findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。4、Mybatis是如何进行分页的？分页插件的原理是什么？注：我出的。答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。举例：select * from student，拦截sql后重写为：select t.* from （select * from student）t&nbsp;limit 0，105、简述Mybatis的插件运行原理，以及如何编写一个插件。注：我出的。答：Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。6、Mybatis执行批量插入，能返回数据库主键列表吗？注：我出的。答：能，JDBC都能，Mybatis当然也能。7、Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？注：我出的。答：Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。8、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？注：我出的。答：第一种是使用&lt;resultMap&gt;标签，逐一定义列名和对象属性名之间的映射关系。第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME&nbsp;AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME&nbsp;AS NaMe，Mybatis一样可以正常工作。有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。9、Mybatis能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。注：我出的。答：能，Mybatis不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把selectOne()修改为selectList()即可；多对多查询，其实就是一对多查询，只需要把selectOne()修改为selectList()即可。关联对象查询，有两种实现方式，一种是单独发送一个sql去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用join查询，一部分列是A对象的属性值，另外一部分列是关联对象B的属性值，好处是只发一个sql查询，就可以把主对象和其关联对象查出来。那么问题来了，join查询出来100条记录，如何确定主对象是5个，而不是100个？其去重复的原理是&lt;resultMap&gt;标签内的&lt;id&gt;子标签，指定了唯一确定一条记录的id列，Mybatis根据&lt;id&gt;列值来完成100条记录的去重复功能，&lt;id&gt;可以有多个，代表了联合主键的语意。同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。举例：下面join查询出来6条记录，一、二列是Teacher对象列，第三列为Student对象列，Mybatis去重复处理后，结果为1个老师6个学生，而不是6个老师6个学生。&nbsp; &nbsp; &nbsp; &nbsp;t_id &nbsp; &nbsp;t_name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;s_id| &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | teacher &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;38 || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | teacher &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;39 || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | teacher &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;40 || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | teacher &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;41 || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | teacher &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;42 || &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1 | teacher &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;43 |10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？注：我出的。答：Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。11、Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？注：我出的。答：不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。原因就是namespace+id是作为Map&lt;String,&nbsp;MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。12、Mybatis中如何执行批处理？注：我出的。答：使用BatchExecutor完成批处理。13、Mybatis都有哪些Executor执行器？它们之间的区别是什么？注：我出的答：Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。14、Mybatis中如何指定使用哪一种Executor执行器？注：我出的答：在Mybatis配置文件中，可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数。15、Mybatis是否可以映射Enum枚举类？注：我出的答：Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。16、Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？注：我出的答：虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。17、简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？注：我出的答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，&lt;parameterMap&gt;标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。&lt;resultMap&gt;标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。18、为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？注：我出的答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的Mybatis系列博客中都有详细讲解和原理分析。原文链接：https://www.cnblogs.com/huajiezh/p/6415388.html","link":"/2017/12/12/mybatis-learn-note/"},{"title":"JS-DOM操作：dom加载完毕执行js、创建节点、遍历节点、查找节点、删除节点","text":"一、dom加载完毕执行js dom可以看成一个树形结构，dom的加载顺序就是从上到下，我们一再强调将js文件放在尾部，就是因为如果js脚本在dom文档构造之前执行，这样js就无法访问dom文档对象模型。 1.1 jquery 等待页面dom树加载完毕，再执行代码 写法一：标准写法 $(document).ready(function(){ ... }); &nbsp; 写法二：简写 $(function(){ .... }) 两种写法是等价的 等待页面所有资源（包括css样式表、dom树、图片、第三方框架）加载完毕，再执行代码 $(window).load(function(){ ... &nbsp; }); 总结：也就是说$(function(){...})会比$(window).load(function(){...})先执行 1.2 js &nbsp; 二、创建节点 2.1 document.createElement 太多了，不复制了，我就用了前面1.1的方法。。详情见参考 参考&gt;&gt;&gt;","link":"/2019/06/05/javascript-dom-operation/"},{"title":"mbatis中做LIKE模糊查询","text":"今天在mbatis中做LIKE模糊查询，需要对一个name字段做模糊查询，发现用#{text}查询不到数据， 后来经过一系列搜索发现按照下面的方法可以进行查询1.参数中直接加入%% param.setUsername(&quot;%CD%&quot;); &nbsp;&nbsp;&nbsp;&nbsp;param.setPassword(&quot;%11%&quot;); &lt;select&nbsp;&nbsp;id=&quot;selectPersons&quot;&nbsp;resultType=&quot;person&quot;&nbsp;parameterType=&quot;person&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;select&nbsp;id,sex,age,username,password&nbsp;from&nbsp;person&nbsp;where&nbsp;true&nbsp; &lt;if&nbsp;test=&quot;username!=null&quot;&gt;&nbsp;AND&nbsp;username&nbsp;LIKE&nbsp;#{username}&lt;/if&gt; &lt;if&nbsp;test=&quot;password!=null&quot;&gt;AND&nbsp;password&nbsp;LIKE&nbsp;#{password}&lt;/if&gt; &lt;/select&gt;2.bind标签&lt;select&nbsp;id=&quot;selectPersons&quot;&nbsp;resultType=&quot;person&quot;&nbsp;parameterType=&quot;person&quot;&gt; &nbsp;&nbsp;&lt;bind&nbsp;name=&quot;pattern&quot;&nbsp;value=&quot;'%'&nbsp;+&nbsp;_parameter.username&nbsp;+&nbsp;'%'&quot;&nbsp;/&gt; &nbsp;&nbsp;select&nbsp;id,sex,age,username,password&nbsp; &nbsp;&nbsp;from&nbsp;person &nbsp;&nbsp;where&nbsp;username&nbsp;LIKE&nbsp;#{pattern} &lt;/select&gt;3.CONCATwhere&nbsp;username&nbsp;LIKE&nbsp;concat(concat('%',#{username}),'%')","link":"/2017/12/05/mybatis-like-query-method/"},{"title":"刚才Mysql又自动关闭了。","text":"还不清楚原因， 下次在慢慢查吧。。。","link":"/2018/03/19/mysql-abnormal-stop/"},{"title":"JSON.stringify() 参数用法详解","text":"JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，如果指定了replacer是一个函数， 则可以替换值，或者如果指定了replacer是一个数组，可选的仅包括指定的属性。语法:JSON.stringify(value[,&nbsp;replacer&nbsp;[,&nbsp;space]])参数:value:将要序列化成 一个JSON 字符串的值。replacer:可选,如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化；关于该参数更详细的解释和示例，请参考使用原生的 JSON 对象一文。space:可选,指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果该参数没有提供（或者为null）将没有空格。返回值:&nbsp;一个表示给定值的JSON字符串。描述:关于序列化，有下面五点注意事项：非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。undefined、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 null（出现在数组中时）。所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。不可枚举的属性会被忽略JSON.stringify({});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'{}' JSON.stringify(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'true' JSON.stringify(&quot;foo&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'&quot;foo&quot;' JSON.stringify([1,&nbsp;&quot;false&quot;,&nbsp;false]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'[1,&quot;false&quot;,false]' JSON.stringify({&nbsp;x:&nbsp;5&nbsp;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'{&quot;x&quot;:5}' JSON.stringify({x:&nbsp;5,&nbsp;y:&nbsp;6});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //&nbsp;&quot;{&quot;x&quot;:5,&quot;y&quot;:6}&quot; JSON.stringify([new&nbsp;Number(1),&nbsp;new&nbsp;String(&quot;false&quot;),&nbsp;new&nbsp;Boolean(false)]);&nbsp;//&nbsp;'[1,&quot;false&quot;,false]' JSON.stringify({x:&nbsp;undefined,&nbsp;y:&nbsp;Object,&nbsp;z:&nbsp;Symbol(&quot;&quot;)});&nbsp;//&nbsp;'{}' JSON.stringify([undefined,&nbsp;Object,&nbsp;Symbol(&quot;&quot;)]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'[null,null,null]'&nbsp; JSON.stringify({[Symbol(&quot;foo&quot;)]:&nbsp;&quot;foo&quot;});&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'{}' JSON.stringify({[Symbol.for(&quot;foo&quot;)]:&nbsp;&quot;foo&quot;},&nbsp;[Symbol.for(&quot;foo&quot;)]);//&nbsp;'{}' JSON.stringify(&nbsp;&nbsp;&nbsp;&nbsp;{[Symbol.for(&quot;foo&quot;)]:&nbsp;&quot;foo&quot;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function&nbsp;(k,&nbsp;v)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(typeof&nbsp;k&nbsp;===&nbsp;&quot;symbol&quot;){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;&quot;a&nbsp;symbol&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;}); //&nbsp;undefined&nbsp;//&nbsp;不可枚举的属性默认会被忽略：JSON.stringify(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.create(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;null,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x:&nbsp;{&nbsp;value:&nbsp;'x',&nbsp;enumerable:&nbsp;false&nbsp;},&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y:&nbsp;{&nbsp;value:&nbsp;'y',&nbsp;enumerable:&nbsp;true&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;)); //&nbsp;&quot;{&quot;y&quot;:&quot;y&quot;}&quot;replacer参数replacer参数可以是一个函数或者一个数组。作为函数，它有两个参数，键(key)值(value)都会被序列化。如果返回一个 Number, 转换成相应的字符串被添加入JSON字符串。如果返回一个 String, 该字符串作为属性值被添加入JSON。如果返回一个 Boolean, &quot;true&quot; 或者 &quot;false&quot;被作为属性值被添加入JSON字符串。如果返回任何其他对象，该对象递归地序列化成JSON字符串，对每个属性调用replaceer方法。除非该对象是一个函数，这种情况将不会被序列化成JSON字符串。如果返回undefined，该属性值不会在JSON字符串中输出。注意: 不能用replacer方法，从数组中移除值(values)，如若返回undefined或者一个函数，将会被null取代。例子(function)function&nbsp;replacer(key,&nbsp;value)&nbsp;{&nbsp;&nbsp;if&nbsp;(typeof&nbsp;value&nbsp;===&nbsp;&quot;string&quot;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;undefined;&nbsp;&nbsp;}&nbsp;&nbsp;return&nbsp;value;} var&nbsp;foo&nbsp;=&nbsp;{foundation:&nbsp;&quot;Mozilla&quot;,&nbsp;model:&nbsp;&quot;box&quot;,&nbsp;week:&nbsp;45,&nbsp;transport:&nbsp;&quot;car&quot;,&nbsp;month:&nbsp;7};var&nbsp;jsonString&nbsp;=&nbsp;JSON.stringify(foo,&nbsp;replacer);JSON序列化结果为&nbsp;{&quot;week&quot;:45,&quot;month&quot;:7}.例子(array)如果replacer是一个数组，数组的值代表将被序列化成JSON字符串的属性名。JSON.stringify(foo,&nbsp;['week',&nbsp;'month']);&nbsp;&nbsp;//&nbsp;'{&quot;week&quot;:45,&quot;month&quot;:7}',&nbsp;只保留“week”和“month”属性值。space 参数space 参数用来控制结果字符串里面的间距。如果是一个数字, 则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多10个空格）；如果是一个字符串，则每一级别会比上一级别多缩进用该字符串（或该字符串的前十个字符）。JSON.stringify({&nbsp;a:&nbsp;2&nbsp;},&nbsp;null,&nbsp;&quot;&nbsp;&quot;);&nbsp;&nbsp;&nbsp;//&nbsp;'{\\n&nbsp;&quot;a&quot;:&nbsp;2\\n}'使用制表符（\\t）来缩进： JSON.stringify({&nbsp;uno:&nbsp;1,&nbsp;dos&nbsp;:&nbsp;2&nbsp;},&nbsp;null,&nbsp;'\\t')//&nbsp;'{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;uno&quot;:&nbsp;1,&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;dos&quot;:&nbsp;2&nbsp;&nbsp;//&nbsp;}'toJSON 方法如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是那个对象被序列化，而是调用 toJSON 方法后的返回值会被序列化，例如：var&nbsp;obj&nbsp;=&nbsp;{&nbsp;&nbsp;foo:&nbsp;'foo',&nbsp;&nbsp;toJSON:&nbsp;function&nbsp;()&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;'bar';&nbsp;&nbsp;}};JSON.stringify(obj);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;'&quot;bar&quot;'JSON.stringify({x:&nbsp;obj});&nbsp;//&nbsp;'{&quot;x&quot;:&quot;bar&quot;}'JSON.stringify用作&nbsp;JavaScript注意JSON不是javascript严格意义上的子集，在JSON中不需要省略两条终线(Line separator和Paragraph separator)但在JavaScript中需要被省略。因此，如果JSON被用作JSONP时，下面方法可以使用：function&nbsp;jsFriendlyJSONStringify&nbsp;(s)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;JSON.stringify(s).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace(/\\u2028/g,&nbsp;'\\u2028').&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;replace(/\\u2029/g,&nbsp;'\\u2029');} var&nbsp;s&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;a:&nbsp;String.fromCharCode(0x2028),&nbsp;&nbsp;&nbsp;&nbsp;b:&nbsp;String.fromCharCode(0x2029)};try&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;eval('('&nbsp;+&nbsp;JSON.stringify(s)&nbsp;+&nbsp;')');}&nbsp;catch&nbsp;(e)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;console.log(e);&nbsp;//&nbsp;&quot;SyntaxError:&nbsp;unterminated&nbsp;string&nbsp;literal&quot;} //&nbsp;No&nbsp;need&nbsp;for&nbsp;a&nbsp;catcheval('('&nbsp;+&nbsp;jsFriendlyJSONStringify(s)&nbsp;+&nbsp;')'); //&nbsp;console.log&nbsp;in&nbsp;Firefox&nbsp;unescapes&nbsp;the&nbsp;Unicode&nbsp;if//&nbsp;&nbsp;&nbsp;logged&nbsp;to&nbsp;console,&nbsp;so&nbsp;we&nbsp;use&nbsp;alertalert(jsFriendlyJSONStringify(s));&nbsp;//&nbsp;{&quot;a&quot;:&quot;\\u2028&quot;,&quot;b&quot;:&quot;\\u2029&quot;}使用 JSON.stringify 结合 localStorage 的例子一些时候，你想存储用户创建的一个对象，并且，即使在浏览器被关闭后仍能恢复该对象。下面的例子是 JSON.stringify 适用于这种情形的一个样板：//&nbsp;创建一个示例数据var&nbsp;session&nbsp;=&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;'screens'&nbsp;:&nbsp;[],&nbsp;&nbsp;&nbsp;&nbsp;'state'&nbsp;:&nbsp;true};session.screens.push({&quot;name&quot;:&quot;screenA&quot;,&nbsp;&quot;width&quot;:450,&nbsp;&quot;height&quot;:250});session.screens.push({&quot;name&quot;:&quot;screenB&quot;,&nbsp;&quot;width&quot;:650,&nbsp;&quot;height&quot;:350});session.screens.push({&quot;name&quot;:&quot;screenC&quot;,&nbsp;&quot;width&quot;:750,&nbsp;&quot;height&quot;:120});session.screens.push({&quot;name&quot;:&quot;screenD&quot;,&nbsp;&quot;width&quot;:250,&nbsp;&quot;height&quot;:60});session.screens.push({&quot;name&quot;:&quot;screenE&quot;,&nbsp;&quot;width&quot;:390,&nbsp;&quot;height&quot;:120});session.screens.push({&quot;name&quot;:&quot;screenF&quot;,&nbsp;&quot;width&quot;:1240,&nbsp;&quot;height&quot;:650}); //&nbsp;使用&nbsp;JSON.stringify&nbsp;转换为&nbsp;JSON&nbsp;字符串//&nbsp;然后使用&nbsp;localStorage&nbsp;保存在&nbsp;session&nbsp;名称里localStorage.setItem('session',&nbsp;JSON.stringify(session)); //&nbsp;然后是如何转换通过&nbsp;JSON.stringify&nbsp;生成的字符串，该字符串以&nbsp;JSON&nbsp;格式保存在&nbsp;localStorage&nbsp;里var&nbsp;restoredSession&nbsp;=&nbsp;JSON.parse(localStorage.getItem('session'));//&nbsp;现在&nbsp;restoredSession&nbsp;包含了保存在&nbsp;localStorage&nbsp;里的对象console.log(restoredSession);","link":"/2017/12/05/javascript-json-stringify/"},{"title":"利用highlight.js和marked渲染和解析markdown文档","text":"1.markdown在后台富文本框中，编辑好markdwon格式的文本，保存进数据库 2.marked.js在页面中展示时，需要首先将markdown格式转为带有html标签的文本，这里选用了marked.js安装：npm install marked --save 2.1 marked的使用12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; import marked from 'marked' marked.setOptions({ renderer: new marked.Renderer(), highlight: function(code,lang) { if (lang &amp;&amp; hljs.getLanguage(lang)) { //用了highlight.js，就需要在这里显示 //return hljs.highlight(lang, code, true).value; } else { //return hljs.highlightAuto(code).value; } }, pedantic: false, gfm: true, tables: true, breaks: false, sanitize: false, smartLists: true, smartypants: false, xhtml: false } );this.content = marked(this.content)//渲染文本&lt;/script&gt;``` 做完上面这步后，就已经把`markdwon`文档解析成了`html`，显示出来是没有样式的 ##### a.原始代码： ![15737864251.png](https://image.hr2812.cn/Fqno8fLWt0ihb9HU611IBbGqzD8T) ##### b.解析后的`html`代码 ![15737868561.png](https://image.hr2812.cn/FvJcgoKW3kq2NVPP5t457WKhU8qX) 可以看到解析后的标签里面是没有样式的，显示的效果如下 ##### c.解析后无代码高亮效果 ![15737869541.png](https://image.hr2812.cn/FiAHwknAWSgm3O5st9OzxD7Ym61j) 这里显示出了`markdown`的引用、和行内代码、代码块的样式，这些样式是`github`提供的。如果项目里面没有引入`github`相关的`css`，就没有这种效果。 #### 3.highlight.js 把上面的注释放开，安装和引用`highlight.js`、和你选择的样式 npm install highlight.jsimport hljs from “highlight.js”import ‘highlight.js/styles/atelier-forest-light.css ``` d.加入后的效果可以看到代码块里面的代码关键字有颜色了。","link":"/2019/11/16/markdown-highlight-marked-simple-demo/"},{"title":"难受一小会儿，过一下就好了。感觉自己没心没肺呀。。","text":"小伙子，你眼光不行呀。 我正在慢慢变成那种我觉得很可悲、可怜的人 心态老是容易出现问题，不乱想的话还好 虽然现实会很残酷，不是每个人都会找到自己所喜欢的人 目前来说，我是没有去喜欢一个人的状态和条件的 更别说一个有了男朋友快要结婚的人 不过我确实心动了 平时很少接近她 可能我没有主动的勇气 感觉这一周，每晚回到家，都很难受 我觉得我的想法很天真，不成熟 其实不想那么多，没那么多想的，好好生活每一天 一个人耐住孤独，那个人终会出现的 我已经这么惨了，还怕什么呢 不过，目前为止我也不后悔我的这次主动，因为我确实喜欢她的样子，喜欢她，不想错过 自己是什么样的人才会遇见什么样的人，对于一个喜欢的人，祝福她 争取以后有机会和她多说话、多交流，然后发现她的一些我不喜欢的地方 恐怕很难发现。就这样吧，写给那个让我心动的女孩。--2019.06.07 &nbsp;","link":"/2019/06/02/no-heart-no-lung-just-one/"},{"title":"有点想辞职做毕业设计了","text":"工作这么久了，学到的不算太多， 快交毕业设计了，现在才做一点点。很慌","link":"/2018/04/19/out-from-work-to-do-graduation/"},{"title":"最近","text":"07.29来成都了。住旅馆找工作。和上家钱差不多。 找房租了，台式在广州没寄回来。买了台MacBook Pro，还在熟悉的使用中。公司项目比我上一家好，人也比较多。很多技术可以学的。一直想着记些笔记，包括面试那些天，都写在有道云笔记了。刚才才把博客的前后端在mac上跑起来。暂时就这样了。","link":"/2020/09/02/recently-life/"},{"title":"部门解散一个多月了，我玩了一个多月。。。","text":"10月31日部门解散。 今天12月9日，玩了三十多天，昨天才开始整理简历。 每天上网玩lol，碎觉，玩明日之后。 越过一天，心里越感到害怕。 还有，我现在是一个人了。 其实很多时候，以前的时候，我和一个人也差不多。 她几乎没有真正走进我的内心。 我也没有把她放在心里。 这段关系，早该结束。 拖了这么久，害人害己。 以后，对待自己的感情，切记慎重。 感情不可儿戏。 自尊自爱，即使不能变成更好的样子。 也不要让自己变得自己越来越不喜欢，越来越害怕。 &nbsp;","link":"/2018/12/10/resignation-30days-degenerate/"},{"title":"rabbitmq安装、简单使用","text":"1、AMQP AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议, 是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品， 不同的开发语言等条件的限制。Erlang中的实现有 RabbitMQ等。 2、消息队列 在计算机科学中，消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。 实际上，消息队列常常保存在链表结构中。拥有权限的进程可以向消息队列中写入或读取消息。&nbsp; 目前，有很多消息队列有很多开源的实现，包括JBoss Messaging、JORAM、Apache ActiveMQ、Sun Open Message Queue、RabbitMQ、IBM MQ、Apache Qpid和HTTPSQS。 3、RabbitMQ简介 RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。 &nbsp;","link":"/2019/03/09/rabbitmq-simple-use/"},{"title":"redis的简单使用","text":"一、简介 redis(REmote DIctionary Server) 是一个由Salvatore Sanfilippo写的key-value存储系统。 Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 二、支持的数据类型 redis支持5种数据类型，String、Hash、List、Set和zset String（字符串） string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。 string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。 string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。 Hash（哈希） Redis hash 是一个键值(key=&gt;value)对集合。 Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。 redis&gt; HMSET myhash field1 \"Hello\" field2 \"World\" \"OK\" redis&gt; HGET myhash field1 \"Hello\" redis&gt; HGET myhash field2 \"World\" 实例中我们使用了 Redis HMSET, HGET 命令，HMSET 设置了两个 field=&gt;value 对, HGET 获取对应 field 对应的 value。 每个 hash 可以存储 232 -1 键值对（40多亿）。 List（列表） Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。 实例 redis 127.0.0.1:6379&gt; lpush runoob redis (integer) 1 redis 127.0.0.1:6379&gt; lpush runoob mongodb (integer) 2 redis 127.0.0.1:6379&gt; lpush runoob rabitmq (integer) 3 redis 127.0.0.1:6379&gt; lrange runoob 0 10 1) \"rabitmq\" 2) \"mongodb\" 3) \"redis\" redis 127.0.0.1:6379&gt; 列表最多可存储 232 - 1 元素 (4294967295, 每个列表可存储40多亿)。 Set（集合） Redis的Set是string类型的无序集合。 &nbsp; 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 &nbsp; sadd 命令 添加一个 string 元素到 key 对应的 set 集合中，成功返回1，如果元素已经在集合中返回 0，如果 key 对应的 set 不存在则返回错误。 &nbsp; sadd key member 实例 redis 127.0.0.1:6379&gt; sadd runoob redis (integer) 1 redis 127.0.0.1:6379&gt; sadd runoob mongodb (integer) 1 redis 127.0.0.1:6379&gt; sadd runoob rabitmq (integer) 1 redis 127.0.0.1:6379&gt; sadd runoob rabitmq (integer) 0 redis 127.0.0.1:6379&gt; smembers runoob &nbsp; 1) \"redis\" 2) \"rabitmq\" 3) \"mongodb\" 注意：以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。 &nbsp; 集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。 &nbsp; zset(sorted set：有序集合) Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。 不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。 &nbsp; zset的成员是唯一的,但分数(score)却可以重复。 &nbsp; zadd 命令 添加元素到集合，元素在集合中存在则更新对应score &nbsp; zadd key score member&nbsp; 实例 redis 127.0.0.1:6379&gt; zadd runoob 0 redis (integer) 1 redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb (integer) 1 redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq (integer) 1 redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq (integer) 0 redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 1000 1) \"mongodb\" 2) \"rabitmq\" 3) \"redis\" &nbsp;","link":"/2019/03/05/redis-simple-demo/"},{"title":"软件工程的6个阶段","text":"一，项目计划阶段。（也可以说是可行性分析阶段） 确定了一个软件以目前的条件可以完成，主要是经济，技术和社会条件，撰写可行性分析报告。需求方和开发方共同探讨项目中的问题的解决方案；需要的资金，人力，物力；社会方面的影响，例如是否符合法律等；对项目的进度和预期效益进行估计。二，项目需求分析阶段。 对用户需求进行分析。将用户的需求用逻辑的软件工程语言表达出来，设计好功能和数据库模型，编写成软件需求设计书。这个阶段要注意的是行业的术语以及行业规则，开发的软件难免遇到不同行业，我们不是那个行业里面的人，所以对用户所在行业的需求分析的时候要正确理解他们的术语和规则。当需求得到用户确认后记得让用户签字。最后提醒一点，需求的变更在项目中很频繁，必须做好需求变更计划用以项目正常进行。三，项目设计阶段。 概要设计就是设计软件的结构，包括组成模块，模块的层次结构，模块的调用关系，每个模块的功能等等。同时，还要设计该项目的应用系统的总体数据结构和数据库结构，即应用系统要存储什么数据，这些数据是什么样的结构，它们之间有什么关系。 详细设计阶段就是为每个模块完成的功能进行具体的描述，要把功能描述转变为精确的、结构化的过程描述。 概要设计阶段通常得到软件结构图。 详细设计阶段常用的描述方式有：流程图、N-S图、PAD图、伪代码等。四，编码阶段。 为程序员分配好编码任务，将软件的设计具体为软件代码。这里注意的是编码语言，工具，环境和编码规范。统一，标准的编码规范可让程序可读和易维护。五，软件测试阶段。 软件测试就是利用测试工具按照测试方案和流程对产品进行功能和性能测试，甚至根据需要编写不同的测试工具，设计和维护测试系统，对测试方案可能出现的问题进行分析和评估。执行测试用例后，需要跟踪故障，以确保开发的产品适合需求。 测试，目的是以较小的代价发现尽可能多的错误。要实现这个目标的关键在于设计一套出色的测试用例。如何才能设计出一套出色的测试用例，关键在于理解测试方法。不同的测试方法有不同的测试用例设计方法。两种常用的测试方法是白盒法测试对象是源程序，依据的是程序内部的的逻辑结构来发现软件的编程错误、结构错误和数据错误。结构错误包括逻辑、数据流、初始化等错误。用例设计的关键是以较少的用例覆盖尽可能多的内部程序逻辑结果。白盒法和黑盒法依据的是软件的功能或软件行为描述，发现软件的接口、功能和结构错误。其中接口错误包括内部/外部接口、资源管理、集成化以及系统错误。六，维护阶段。 对软件正式交付使用过程中出现的软件的bug进行修复，调整软件以适应正式环境，编写软件的维护报告。转自http://www.cnblogs.com/wattone/archive/2010/03/27/1666662.html博客园的一篇博客","link":"/2017/12/05/software-engineering-6-stage/"},{"title":"Resin服务器部署web项目","text":"Resin服务器部署web项目1、resin介绍&nbsp;Resin是一个非常流行的application server，对servlet和JSP提供了良好的支持，性能也比较优良，resin自身采用JAVA语言开发。是一个提供高性能的，支持Java/PHP的应用服务器。&nbsp;Resin官网：http://www.caucho.com，一下将在resin-4.0.39的基础上展开。2、resin配置&nbsp;在conf目录下的resin.xml文件中找到&lt;host id=&quot;&quot; root-directory=&quot;.&quot;&gt;，在其标签对中加入web项目的路径，如下：&lt;host&nbsp;id=&quot;&quot;&nbsp;root-directory=&quot;.&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;!-- &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;webapps&nbsp;can&nbsp;be&nbsp;overridden/extended&nbsp;in&nbsp;the&nbsp;resin.xml &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--&gt; &lt;web-app&nbsp;id=&quot;queryapi&quot;&nbsp;root-directory=&quot;/test/web/data-query-server&quot;/&gt;&lt;/host&gt;host的id就是你的主机名称，而web-app的id就是浏览器访问地址，web-app的root-directory表示编译好的web工程。端口号可在resin.properties中去配置。如上，在浏览器中的访问：http://xxxxx:8443/queryapi/goods/，后面加上你项目的url即可。注意，项目需要时编译过的class文件在一个host(虚拟主机)下可以配置多个web-app配置多个虚拟机来配置多个web-app，每个host下配置一个web-app即可3、启动resin服务//*查看resin进程 jps&nbsp;-lvm ps&nbsp;-ef&nbsp;|grep&nbsp;resin //启动resinbin目录下：resin.sh&nbsp;start&nbsp; //关闭resinbin目录下：shutdown.sh或者kill&nbsp;-9&nbsp;resinid","link":"/2017/12/23/resin-deploy-web-project/"},{"title":"SpringBoot面试","text":"1、什么是Springboot? 它是Spring开源组织下面的一个子项目，用来简化Spring的初始搭建和开发过程，提供了许多启动器，它内嵌了servlet容器tomcat和jetty，部署时不需要war文件，直接运行main方法。 2、你如何理解 Spring Boot 中的 Starters？ Starters可以理解为启动器，它包含一系列可以集成到应用里面的依赖包。如你想使用 Spring JPA 访问数据库，只要加入 spring-boot-starter-data-jpa 启动器依赖就能使用了。 3、springboot常用的starter有哪些？ spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持 spring-boot-starter-data-jpa 数据库支持 spring-boot-starter-data-redis redis数据库支持 spring-boot-starter-data-solr solr支持 mybatis-spring-boot-starter&nbsp; 第三方的mybatis集成starter 4、SpringBoot的自动配置是什么？ 当通过自动注入一个类实例之前，Spting容器需要管理这个类的实例，以往都是在xml通过一个bean标签、或者在类定义上加上@Component、@Configuration等注解来实现。这样才能使用注解注入这个类的实例。对于一些jar包里面的类的实例，以往需要在标签中引入写出这些类的实现类类名和路径。而SpringBoot自动配置功能，会自动配置一些内，注入在容器中，特别是对于一些jar包中的类，这样自动配置后我们只需要通过@Autowired或@Resource使用就可以了。 5、springboot自动配置的原理？ 在spring程序main方法中 添加@SpringBootApplication或者@EnableAutoConfiguration 会自动去gradle、maven中读取每个starter中的spring.factories文件&nbsp; 该文件里配置了所有需要被创建spring容器中的bean 6、SpringBoot常用注解？ @SpringBootApplication、@EnableAutoConfiguration、@ComponentScan等等 7、SpringBoot实现热部署？ 添加开发者工具集spring-boot-devtools。 8、SpringBoot读取配置文件内容的几种方式？ a.@Value注解读取方式 b.@ConfigurationProperties注解读取方式 c.类定义上面的注解加载配置文件：@PropertySource(value={\"config/db-config.properties\"})，加上@Value 9、如何在 Spring Boot 启动的时候运行一些特定的代码？ 可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法 &nbsp; &nbsp; &nbsp;","link":"/2019/03/07/spring-boot-interview/"},{"title":"解决使用redis作为session缓存报错Error:nosuchkey的问题","text":"spring的issue https://github.com/spring-projects/spring-session/issues/954原答案是 Updated my codes to 2.0.0.RELEASE 但好像没什么用。 spring整合了SpringSecurity，本来如果直接浏览器访问接口没问题，但是，前端使用vue访问就会出现 1Error: no such key 本来没什么事，后来发现vue的同一个页面下，单独一个请求没问题，但如果多次请求就出现接口报错的情况，找到了上诉答案。 因为是spring整合了spring Security，在原答案中看到，每次检查原session的时候如果不存在的话，就会创建新的session，就想直接把security的session禁用掉试试怎么样，没想到成功了 贴下security的配置，将security的session管理禁用掉，并且从原有的session中获取就行了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.zjzc.crm.security.config;import org.springframework.context.annotation.Configuration;import org.springframework.core.annotation.Order;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.http.SessionCreationPolicy;/** * spring-security配置 * */@Configuration@Order(99)public class WebSecurityConfig extends AbstractWebSecurityConfig { @Override protected void configure(HttpSecurity security) throws Exception { /** * always – 如果session不存在总是需要创建； * ifRequired – 仅当需要时，创建session(默认配置)； * never – 框架从不创建session，但如果已经存在，会使用该session ； * stateless – Spring Security不会创建session，或使用session； * --------------------- * 作者：neweastsun * 来源：CSDN * 原文：https://blog.csdn.net/neweastsun/article/details/79371175 * 版权声明：本文为博主原创文章，转载请附上博文链接！ */ security.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.NEVER); /* * \"migrateSession\"，即认证时，创建一个新http session，原session失效，属性从原session中拷贝过来 * “none”，原session保持有效； * “newSession”，新创建session，且不从原session中拷贝任何属性。 */ security.sessionManagement().sessionFixation().none(); security .authorizeRequests() .antMatchers( \"/login/**\",\"/validate/**\",\"/sys/user/resetPWD\",\"/claim/fileUpload\").permitAll();//权限不校验的接口 super.configure(security); }} 以上是这个问题的解决办法，参考自https://blog.csdn.net/neweastsun/article/details/79371175。我遇到的是项目中设置的是SessionCreationPolicy.stateless，改成NEVER就好了。这个问题一直存在，系统时不时会报这个错误，打印出来的异常信息又多。我观察，在页面中频繁调用接口就会出现这个问题。","link":"/2020/03/25/spring-session-redis-problem-error-no-such-key/"},{"title":"SpringMVC的学习笔记","text":"一、SpringMVC的工作流程1.用户发送请求到前端控制器DispatcherServlet2.DispatcherServlet收到请求，并调用处理器映射器HandlerMappering3.处理器映射器找到具体的处理器生成处理器对象和处理器拦截器，并返回给DispatcherServlet4.控制器调用处理器设配器HandlerAdapter5.处理器适配器根据处理器拦截器找到具体的处理器（后端控制器Controller）6.Handler(Controller)调用完业务层方法返回ModelView给Adapter7.Adapter又将ModelView返回给前端控制器8.前端控制器得到modelAndView又将其传给视图解析器ViewResolver9.视图解析器得到ModelAndView返回解析出的视图View10.前端控制器根据View请求视图渲染，得到jstl渲染后的视图11.最后将结果响应给用户1.关于Spring MVC的核心控制器DispatcherServlet的作用，以下说法错误的是（ ）A.它负责接收HTTP请求B.加载配置文件C.实现业务操作D.初始化上下应用对象ApplicationContextSpringMVC是Spring中的模块，它实现了mvc设计模式，首先用户发起请求，请求到达SpringMVC的前端控制器(DispatcherServlet)，前端控制器根据用户的url请求处理器映射器查找匹配该url的handle，并返回一个执行链，前端控制器再请求处理器适配器调用相应的handle进行处理并返回给前端控制器一个modelAndView,前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染，并把数据装入到request域，返回给用户。DispatcherServlet作为SpringMVC的前端控制器，负责接收用户的请求，并根据用户的请求返回相应的视图给用户。实现业务在service层，所以c答案错误。正确答案：C2017-12-08&nbsp;22:45:402.下面有关spring的依赖注入，说法错误的是（）A.依赖注入通常有如下两种：设值注入和构造注入：B.构造注入可以在构造器中决定依赖关系的注入顺序，优先依赖的优先注入C.当设值注入与构造注入同时存在时，先执行构造注入，再执行设值注入D.设值注入是指IoC容器使用属性的setter方法来注入被依赖的实例。这种注入方式比较简单、直观使用构造函数依赖注入时，Spring保证一个对象所有依赖的对象先实例化后，才实例化这个对象。使用set方法依赖注入时，Spring首先实例化对象，然后才实例化所有依赖的对象。当设值注入与构造注入同时存在时，先执行设值注入，再执行构造注入。3.将元数据配置到Spring容器，下面哪个方法是不正确的（）A.通过编组与解组对象B.注解基础配置C.Java基础配置D.XML基础配置有三种方式向Spring 容器提供元数据:1，XML配置文件；2，基于注解配置；3，基于Java的配置，死概念记住即可。正确答案：A4.下面哪个不是Spring 的注解（）A.@AspectB.@ServiceC.@ComponentD.@ControllerE.@View正确答案：E考察对spring的熟悉程度，除E选项之外都是较常用注解。5.下面有关SPRING的事务传播特性，说法错误的是（）A.PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行B.PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常C.PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起D.PROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚正确答案：B事务的传播属性介绍：PROPAGATION_REQUIRED --支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。PROPAGATION_SUPPORTS --支持当前事务，如果当前没有事务，就以非事务方式执行。PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。PROPAGATION_REQUIRES_NEW --新建事务，如果当前存在事务，把当前事务挂起。PROPAGATION_NOT_SUPPORTED --以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。PROPAGATION_NEVER --以非事务方式执行，如果当前存在事务，则抛出异常。6.下列关于Spring特性中IoC描述错误的是（）A.IoC就是指程序之间的关系由程序代码直接操控B.所谓“控制反转”是指控制权由应用代码转到外部容器，即控制权的转移C.IoC将控制创建的职责搬进了框架中，从应用代码脱离开来D.使用Spring的IoC容器时只需指出组件需要的对象，在运行时Spring的IoC容器会根据XML配置数据提供给它IOC，即控制反转（Inversion of Control，英文缩写为IoC），是一个重要的面向对象编程的法则来削减计算机程序的耦合问题，也是轻量级的Spring框架的核心。 控制反转一般分为两种类型，依赖注入（Dependency Injection，简称DI）和依赖查找（Dependency Lookup）。","link":"/2017/12/06/springmvc-learn-note/"},{"title":"天气有点冷最近","text":"工作也快一个半月了。听歌吧","link":"/2018/02/01/suibi-2018-01-30/"},{"title":"CountDownLatch、CyclicBarrier和Semaphore类的简单使用","text":"题目：多线程之间需要等待协调，才能完成某种工作，问怎么设计这种协调方案？如：子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次。 本文阅读大概需要30分钟。 这个题目主要考查多线程之间的协调，关于线程的协调与通信怎么处理的思路见面试题10。在并发编程中经常会使用到一些并发工具类，来对线程的并发量、执行流程、资源依赖等进行控制。这里我们主要探讨三个经常使用的并发工具类：CountDownLatch，CyclicBarrier和Semaphore。 1. CountDownLatch 从CountDownLatch的字面意思就可以体现出其设计模型，countdown在英语里具有倒计时的（倒数）意思，Latch就是门闩的意思。CountDownLatch的构造函数接受一个int值作为计数器的初始值N，当程序调用countDown()的时候，N便会减1（体现出了倒数的意义），当N值减为0的时候，阻塞在await()的线程便会唤醒，继续执行。这里通过一个例子来说明其应用场景。 假设我们主线程需要创建5个工作线程来分别执行5个任务，主线程需要等待5个任务全部完成后才会进行后续操作，那么我们就可以声明N=5的CountDownLatch，来进行控制。 代码如下： 123456789101112131415161718192021222324public class CountDownLatchDemo { private static final CountDownLatch countDownLatch = new CountDownLatch(5); public static void main(String[] args) throws InterruptedException { //循环创建5个工作线程 for( int ix = 0; ix != 5; ix++ ){ new Thread(new Runnable() { public void run() { try{ System.out.println( Thread.currentThread().getName() + \" start\" ); Thread.sleep(1000); countDownLatch.countDown(); System.out.println( Thread.currentThread().getName() + \" stop\" ); } catch ( InterruptedException ex ){ } } }, \"Task-Thread-\" + ix ).start(); Thread.sleep(500); } //主线程等待所有任务完成 countDownLatch.await(); System.out.println(\"All task has completed.\"); } } 运行结果： 1234567891011Task-Thread-0 startTask-Thread-1 startTask-Thread-0 stopTask-Thread-2 startTask-Thread-1 stopTask-Thread-3 startTask-Thread-2 stopTask-Thread-4 startTask-Thread-3 stopTask-Thread-4 stopAll task has completed. 在主线程创建了5个工作线程后，就会阻塞在countDownLatch.await()，等待5个工作线程全部完成任务后返回。任务的执行顺序可能会不同，但是任务完成的Log一定会在最后显示。CountDownLatch通过计数器值的控制，实现了允许一个或多个线程等待其他线程完成操作的并发控制。 2. CyclicBarrier CyclicBarrier就字面意思是可循环的屏障，其体现了两个特点，可循环和屏障。调用CyclicBarrier的await()方法便是在运行线程中插入了屏障，当线程运行到这个屏障时，便会阻塞在await()方法中，直到等待所有线程运行到屏障后，才会返回。CyclicBarrier的构造函数同样接受一个int类型的参数，表示屏障拦截线程的数目。另一个特点循环便是体现处出了CyclicBarrier与CountDownLatch不同之处了，CyclicBarrier可以通过reset()方法，将N值重置，循环使用，而CountDownLatch的计数器是不能重置的。此外，CyclicBarrier还提供了一个更高级的用法，允许我们设置一个所有线程到达屏障后，便立即执行的Runnable类型的barrierAction（注意：barrierAction不会等待await()方法的返回才执行，是立即执行！）机会，这里我们通过以下代码来测试一下CyclicBarrier的特性。 代码如下： 1234567891011121314151617181920212223242526public class CyclicBarrierDemo { private final static CyclicBarrier cyclicBarrier = new CyclicBarrier(5, new MyBarrierAction()); private final static AtomicInteger atcIx = new AtomicInteger(1); public static void main(String[] args) { for (int ix = 0; ix != 10; ix++){ new Thread(new Runnable() { public void run() { try{ System.out.println(Thread.currentThread().getName() + \" start\"); Thread.sleep(atcIx.getAndIncrement() * 1000 ); cyclicBarrier.await(); System.out.println( Thread.currentThread().getName() + \" stop\" ); } catch ( Exception ex){ } } }, \"Thread-\" + ix).start(); } } private static class MyBarrierAction implements Runnable { @Override public void run() { System.out.println(\"MyBarrierAction is call.\"); } }} 运行结果： 1234567891011Thread-0 startThread-1 startThread-2 startThread-3 startThread-4 startMyBarrierAction is call.Thread-4 stopThread-0 stopThread-1 stopThread-2 stopThread-3 stop 根据运行结果，我们可以看到一下几点： 首先在线程没有调用够N次cyclicBarrier.await()时，所有线程都会阻塞在cyclicBarrier.await()上，也就是说必须N个线程同时到达屏障，才会所有线程越过屏障继续执行。 验证了BarrierAction的执行时机是所有阻塞线程都到达屏障之后，并且BarrierAction执行后，所有线程才会从await()方法返回，继续执行。 3. Semaphore Semaphore信号量并发工具类，其提供了aquire()和release()方法来进行并发控制。Semaphore一般用于资源限流，限量的工作场景，例如数据库连接控制。假设数据库的最大负载在10个连接，而现在有100个客户端想进行数据查询，显然我们不能让100个客户端同时连接上来，找出数据库服务的崩溃。那么我们可以创建10张令牌，想要连接数据库的客户端，都必须先尝试获取令牌（Semaphore.aquire()），当客户端获取到令牌后便可以进行数据库连接，并在完成数据查询后归还令牌（Semaphore.release()），这样就能保证同时连接数据库的客户端不超过10个，因为只有10张令牌，这里给出该场景的模拟代码。 代码如下： 123456789101112131415161718public class SemaphoreDemo { private static final Semaphore semaphoreToken = new Semaphore(10); public static void main(String[] args) { for (int ix = 0; ix != 100; ix++) { new Thread(new Runnable() { public void run() { try { semaphoreToken.acquire(); System.out.println(\"select * from xxx\"); semaphoreToken.release(); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } }} 也许有同学会问，aquire()函数获取许可证的顺序和调用的先后顺序有关系吗，也就是说该例子中客户端是否是排队获取令牌的？答案不是，因为Semaphore默认是非公平的，当然其构造函数提供了设置为公平信号量的参数。 ####4. 本例答案 1234567891011121314151617181920212223242526272829303132333435public class Question12 { public static void main(String[] args) throws InterruptedException { final Object object = new Object(); new Thread(new Runnable() { public void run() { for (int i = 0; i &lt; 50; i++) { synchronized (object) { for (int j = 0; j &lt; 10; j++) { System.out.println(\"SubThread:\" + (j + 1)); } object.notify(); try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } }).start(); for (int i = 0; i &lt; 50; i++) { synchronized (object) { //主线程让出锁，等待子线程唤醒 object.wait(); for (int j = 0; j &lt; 100; j++) { System.out.println(\"MainThread:\" + (j + 1)); } object.notify(); } } }} 这个题目例子比较多，最好自己去分析跑一下代码，结合代码来分析理解这些概念。","link":"/2019/11/19/some-multi-thread-utilClass-to-use/"},{"title":"springboot默认创建的bean是单实还是多例","text":"springboot默认创建的bean是单实还是多例曾经面试的时候有面试官问我spring的controller是单例还是多例，结果我傻逼的回答当然是多例，要不然controller类中的非静态变量如何保证是线程安全的，这样想起似乎是对的，但是不知道（主要是我没看过spring的源码，不知道真正的内在意图）为什么spring的controller是单例的。 先看看spring的bean作用域有几种，分别有啥不同。 spring bean作用域有以下5个： singleton:单例模式，当spring创建applicationContext容器的时候，spring会欲初始化所有的该作用域实例，加上lazy-init就可以避免预处理； prototype：原型模式，每次通过getBean获取该bean就会新产生一个实例，创建后spring将不再对其管理； ====下面是在web项目下才用到的=== request：搞web的大家都应该明白request的域了吧，就是每次请求都新产生一个实例，和prototype不同就是创建后，接下来的管理，spring依然在监听 session:每次会话，同上 global session:全局的web域，类似于servlet中的application 好了，上面都说了spring的controller默认是单例，那很自然就是singleton了。 再看一个例子，看看单例会不会有我说的那种问题（就是类中定义的非静态变量线程安全问题），当然下面这个例子我是实验过的， 要不然也不敢发出来 为什么spring要默认是单例呢？原因有二： 1、为了性能。 2、不需要多例。 1、这个不用废话了，单例不用每次都new，当然快了。 2、不需要实例会让很多人迷惑，因为spring mvc官方也没明确说不可以多例。 我这里说不需要的原因是看开发者怎么用了，如果你给controller中定义很多的属性，那么单例肯定会出现竞争访问了。 因此，只要controller中不定义属性，那么单例完全是安全的。下面给个例子说明下： 1234567891011121314@Controllerpublic class MultViewController { private int index = 0;//非静态 @RequestMapping(\"/show\") public String toShow(ModelMap model) { System.out.println(++i); return\"show\"; } @RequestMapping(\"/test\") public String test() { System.out.println(++i); return\"test\"; }} 从此可见，单例是不安全的，会导致属性重复使用。 最佳实践： 1、不要在controller中定义成员变量。 2、万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式","link":"/2020/03/21/springboot-controller-singleton-or-prototype/"},{"title":"nenene","text":"快死了吧。、 &lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=458725721&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt;","link":"/2018/12/17/to-find-something-be-proud-of/"},{"title":"在ubuntu上面用rbenv安装ruby出现的错误","text":"如图","link":"/2018/01/22/ubuntu-rbenv-ruby/"},{"title":"UEditor的数据回显","text":"在使用UEditor的时候，时候需要修改数据库中保存的由UEditor编辑的内容。这时需要，页面UEditor回显数据。一、使用input隐藏域和ue.setContet方法&lt;input&nbsp;type=&quot;text&quot;&nbsp;value=&quot;${topic.content}&quot;&nbsp;id=&quot;connt&quot;&nbsp;/&gt; ue.ready(function()&nbsp;{//编辑器初始化完成再赋值&nbsp;&nbsp; ue.setContent($(&quot;#connt&quot;).val());&nbsp;&nbsp;&nbsp;&nbsp;//赋值给UEditor&nbsp;&nbsp; });但是由于，回显数据里面带有标签，所有即使设置成hidden，也会显示出来，此方法作废二、直接给js赋值，然后在初始化编辑器&lt;script&nbsp;id=&quot;topicEditor&quot;&nbsp;name=&quot;content&quot;&nbsp;type=&quot;text/plain&quot;&gt; ${topic.content} var&nbsp;ue&nbsp;=&nbsp;UE.getEditor(&nbsp;'topicEditor'); &lt;/script&gt;最后成功解决。","link":"/2017/12/08/ueditor-echodata-update-toshow/"},{"title":"对Java Serializable（序列化）的理解和总结","text":"【CSDN转载】我对Java Serializable（序列化）的理解和总结 1. 序列化是干什么的？&ensp;&ensp; 简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 2. 什么情况下需要序列化2.1 当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；2.2 当你想用套接字在网络上传送对象的时候；2.3 当你想通过RMI传输对象的时候； 3. 当对一个对象实现序列化时，究竟发生了什么？&ensp;&ensp; 在没有序列化前，每个保存在堆（Heap）中的对象都有相应的状态（state），即实例变量（instance ariable）比如： 123456789101112java 代码Foo myFoo = new Foo(); myFoo .setWidth(37); myFoo.setHeight(70); ``` &amp;ensp;&amp;ensp; 当通过下面的代码序列化之后，MyFoo对象中的width和Height实例变量的值（37，70）都被保存到foo.ser文件中，这样以后又可以把它 从文件中读出来，重新在堆中创建原来的对象。当然保存时候不仅仅是保存对象的实例变量的值，JVM还要保存一些小量信息，比如类的类型等以便恢复原来的对 象。```javajava 代码FileOutputStream fs = new FileOutputStream(\"foo.ser\"); ObjectOutputStream os = new ObjectOutputStream(fs); os.writeObject(myFoo); 4. 实现序列化（保存到一个文件）的步骤123456789101112131. Make a FileOutputStream FileOutputStream fs = new FileOutputStream(\"foo.ser\"); 2. Make a ObjectOutputStream ObjectOutputStream os = new ObjectOutputStream(fs); 3. write the objectos.writeObject(myObject1); os.writeObject(myObject2); os.writeObject(myObject3); 4. close the ObjectOutputStreamos.close(); 5. 举例说明123456789101112131415161718192021222324252627282930import java.io.*; public class Box implements Serializable { private int width; private int height; public void setWidth(int width){ this.width = width; } public void setHeight(int height){ this.height = height; } public static void main(String[] args){ Box myBox = new Box(); myBox.setWidth(50); myBox.setHeight(30); try{ FileOutputStream fs = new FileOutputStream(\"foo.ser\"); ObjectOutputStream os = new ObjectOutputStream(fs); os.writeObject(myBox); os.close(); }catch(Exception ex){ ex.printStackTrace(); } } } 6. 相关注意事项序列化时，只对对象的状态进行保存，而不管对象的方法；当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口；当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；并非所有的对象都可以序列化，,至于为什么不可以，有很多原因了,比如：6.1 安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。6.2 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分 配，而且，也是没有必要这样实现。 &ensp;&ensp; 这个确实是个问题.当年在学习java基础的时候,也问过类似的问题.对呀.为何要进行序列化呢.不进行序列化,我的程序不跑的好好的吗?你想要什么结果,我也能给解决不是.我想说确实是这样,如果你的程序与网络无关,那很好你已经可以摒弃它了. 那下面我来简单分析下为何java需要进行序列化呢. &ensp;&ensp; 首先我们要明白,序列化是做什么作用的.java序列化: 以特定的方式对类实例的瞬时状态进行编码保存的一种操作.(可能不是很精确,咱不是搞学术的,看懂即可).从此定义可以看出,序列化作用的对象是类的实例.对实例进行序列化,就是保存实例当前在内存中的状态.包括实例的每一个属性的值和引用等. &ensp;&ensp; 既然后序列化,便会有反序列化.反序列化的作用便是将序列化后的编码解码成类实例的瞬时状态.申请等同的内存保存该实例. &ensp;&ensp; 从上述定义可以发现,序列化就是为了保存java的类对象的状态的.保存这个状态的作用主要用于不同jvm之间进行类实例间的共享.在ORMaping中的缓存机制,进行缓存同步时,便是常见的java序列化的应用之一.在进行远程方法调用,远程过程调用时,采用序列化对象的传输也是一种应用…当你想从一个jvm中调用另一个jvm的对象时,你就可以考虑使用序列化了. &ensp;&ensp; 简而言之:序列化的作用就是为了不同jvm之间共享实例对象的一种解决方案.由java提供此机制,效率之高,是其他解决方案无法比拟的.自家的东西嘛. 理解Java对象序列化&ensp;&ensp; 关于Java序列化的文章早已是汗牛充栋了，本文是对我个人过往学习，理解及应用Java序列化的一个总结。此文内容涉及Java序列化的基本原理，以及多种方法对序列化形式进行定制。在撰写本文时，既参考了Thinking in Java, Effective Java，JavaWorld，developerWorks中的相关文章和其它网络资料，也加入了自己的实践经验与理解，文、码并茂，希望对大家有所帮助。(2012.02.14最后更新) 1. 什么是Java对象序列化Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。使用Java对象序列化，在保存对象时，会把其状态保存为一组字节，在未来，再将这些字节组装成对象。必须注意地是，对象序列化保存的是对象的”状态”，即它的成员变量。由此可知，对象序列化不会关注类中的静态变量。除了在持久化对象时会用到对象序列化之外，当使用RMI(远程方法调用)，或在网络中传递对象时，都会用到对象序列化。Java序列化API为处理对象序列化提供了一个标准机制，该API简单易用，在本文的后续章节中将会陆续讲到。 2. 简单示例在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。此处将创建一个可序列化的类Person，本文中的所有示例将围绕着该类或其修改版。Gender类，是一个枚举类型，表示性别 123public enum Gender { MALE, FEMALE} 如果熟悉Java枚举类型的话，应该知道每个枚举类型都会默认继承类java.lang.Enum，而该类实现了Serializable接口，所以枚举类型对象都是默认可以被序列化的。Person类，实现了Serializable接口，它包含三个字段：name，String类型；age，Integer类型；gender，Gender类型。另外，还重写该类的toString()方法，以方便打印Person实例中的内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Person implements Serializable { private String name = null; private Integer age = null; private Gender gender = null; public Person() { System.out.println(\"none-arg constructor\"); } public Person(String name, Integer age, Gender gender) { System.out.println(\"arg constructor\"); this.name = name; this.age = age; this.gender = gender; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } public Gender getGender() { return gender; } public void setGender(Gender gender) { this.gender = gender; } @Override public String toString() { return \"[\" + name + \", \" + age + \", \" + gender + \"]\"; }} SimpleSerial，是一个简单的序列化程序，它先将一个Person对象保存到文件person.out中，然后再从该文件中读出被存储的Person对象，并打印该对象。 12345678910111213141516public class SimpleSerial { public static void main(String[] args) throws Exception { File file = new File(\"person.out\"); ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file)); Person person = new Person(\"John\", 101, Gender.MALE); oout.writeObject(person); oout.close(); ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file)); Object newPerson = oin.readObject(); // 没有强制转换到Person类型 oin.close(); System.out.println(newPerson); }} 上述程序的输出的结果为： 12arg constructor[John, 31, MALE] 此时必须注意的是，当重新读取被保存的Person对象时，并没有调用Person的任何构造器，看起来就像是直接使用字节将Person对象还原出来的。当Person对象被保存到person.out文件中之后，我们可以在其它地方去读取该文件以还原对象，但必须确保该读取程序的CLASSPATH中包含有Person.class(哪怕在读取Person对象时并没有显示地使用Person类，如上例所示)，否则会抛出ClassNotFoundException。 3. Serializable的作用为什么一个类实现了Serializable接口，它就可以被序列化呢？在上节的示例中，使用ObjectOutputStream来持久化对象，在该类中有如下代码： 1234567891011121314151617181920private void writeObject0(Object obj, boolean unshared) throws IOException { if (obj instanceof String) { writeString((String) obj, unshared); } else if (cl.isArray()) { writeArray(obj, desc, unshared); } else if (obj instanceof Enum) { writeEnum((Enum) obj, desc, unshared); } else if (obj instanceof Serializable) { writeOrdinaryObject(obj, desc, unshared); } else { if (extendedDebugInfo) { throw new NotSerializableException(cl.getName() + \"\\n\" + debugInfoStack.toString()); } else { throw new NotSerializableException(cl.getName()); } } } 从上述代码可知，如果被写对象的类型是String，或数组，或Enum，或Serializable，那么就可以对该对象进行序列化，否则将抛出NotSerializableException。 4. 默认序列化机制如果仅仅只是让某个类实现Serializable接口，而没有其它任何处理的话，则就是使用默认序列化机制。使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。 5. 影响序列化在现实应用中，有些时候不能使用默认序列化机制。比如，希望在序列化过程中忽略掉敏感数据，或者简化序列化过程。下面将介绍若干影响序列化的方法。 5.1 transient关键字当某个字段被声明为transient后，默认序列化机制就会忽略该字段。此处将Person类中的age字段声明为transient，如下所示， 12345public class Person implements Serializable { transient private Integer age = null; } 再执行SimpleSerial应用程序，会有如下输出： 12arg constructor[John, null, MALE] 可见，age字段未被序列化。 5.2 writeObject()方法与readObject()方法对于上述已被声明为transitive的字段age，除了将transitive关键字去掉之外，是否还有其它方法能使它再次可被序列化？方法之一就是在Person类中添加两个方法：writeObject()与readObject()，如下所示： 123456789101112131415public class Person implements Serializable { transient private Integer age = null; private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeInt(age); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); age = in.readInt(); }} 在writeObject()方法中会先调用ObjectOutputStream中的defaultWriteObject()方法，该方法会执行默认的序列化机制，如5.1节所述，此时会忽略掉age字段。然后再调用writeInt()方法显示地将age字段写入到ObjectOutputStream中。readObject()的作用则是针对对象的读取，其原理与writeObject()方法相同。再次执行SimpleSerial应用程序，则又会有如下输出： 12arg constructor[John, 31, MALE] 必须注意地是，writeObject()与readObject()都是private方法，那么它们是如何被调用的呢？毫无疑问，是使用反射。详情可见ObjectOutputStream中的writeSerialData方法，以及ObjectInputStream中的readSerialData方法。 5.3 Externalizable接口无论是使用transient关键字，还是使用writeObject()和readObject()方法，其实都是基于Serializable接口的序列化。JDK中提供了另一个序列化接口–Externalizable，使用该接口之后，之前基于Serializable接口的序列化机制就将失效。此时将Person类修改成如下， 12345678910111213141516171819202122232425262728293031323334353637383940public class Person implements Externalizable { private String name = null; transient private Integer age = null; private Gender gender = null; public Person() { System.out.println(\"none-arg constructor\"); } public Person(String name, Integer age, Gender gender) { System.out.println(\"arg constructor\"); this.name = name; this.age = age; this.gender = gender; } private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeInt(age); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); age = in.readInt(); } @Override public void writeExternal(ObjectOutput out) throws IOException { } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { } } 此时再执行SimpleSerial程序之后会得到如下结果： 123arg constructornone-arg constructor[null, null, null] 从该结果，一方面可以看出Person对象中任何一个字段都没有被序列化。另一方面，如果细心的话，还可以发现这此次序列化过程调用了Person类的无参构造器。Externalizable继承于Serializable，当使用该接口时，序列化的细节需要由程序员去完成。如上所示的代码，由于writeExternal()与readExternal()方法未作任何处理，那么该序列化行为将不会保存/读取任何一个字段。这也就是为什么输出结果中所有字段的值均为空。另外，若使用Externalizable进行序列化，当读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。这就是为什么在此次序列化过程中Person类的无参构造器会被调用。由于这个原因，实现Externalizable接口的类必须要提供一个无参的构造器，且它的访问权限为public。对上述Person类作进一步的修改，使其能够对name与age字段进行序列化，但要忽略掉gender字段，如下代码所示： 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person implements Externalizable { private String name = null; transient private Integer age = null; private Gender gender = null; public Person() { System.out.println(\"none-arg constructor\"); } public Person(String name, Integer age, Gender gender) { System.out.println(\"arg constructor\"); this.name = name; this.age = age; this.gender = gender; } private void writeObject(ObjectOutputStream out) throws IOException { out.defaultWriteObject(); out.writeInt(age); } private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException { in.defaultReadObject(); age = in.readInt(); } @Override public void writeExternal(ObjectOutput out) throws IOException { out.writeObject(name); out.writeInt(age); } @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { name = (String) in.readObject(); age = in.readInt(); } } 执行SimpleSerial之后会有如下结果： 123arg constructornone-arg constructor[John, 31, null] 5.4 readResolve()方法当我们使用Singleton模式时，应该是期望某个类的实例应该是唯一的，但如果该类是可序列化的，那么情况可能会略有不同。此时对第2节使用的Person类进行修改，使其实现Singleton模式，如下所示： 12345678910111213141516171819202122232425262728public class Person implements Serializable { private static class InstanceHolder { private static final Person instatnce = new Person(\"John\", 31, Gender.MALE); } public static Person getInstance() { return InstanceHolder.instatnce; } private String name = null; private Integer age = null; private Gender gender = null; private Person() { System.out.println(\"none-arg constructor\"); } private Person(String name, Integer age, Gender gender) { System.out.println(\"arg constructor\"); this.name = name; this.age = age; this.gender = gender; } } 同时要修改SimpleSerial应用，使得能够保存/获取上述单例对象，并进行对象相等性比较，如下代码所示： 12345678910111213141516public class SimpleSerial { public static void main(String[] args) throws Exception { File file = new File(\"person.out\"); ObjectOutputStream oout = new ObjectOutputStream(new FileOutputStream(file)); oout.writeObject(Person.getInstance()); // 保存单例对象 oout.close(); ObjectInputStream oin = new ObjectInputStream(new FileInputStream(file)); Object newPerson = oin.readObject(); oin.close(); System.out.println(newPerson); System.out.println(Person.getInstance() == newPerson); // 将获取的对象与Person类中的单例对象进行相等性比较 }} 执行上述应用程序后会得到如下结果： 123arg constructor[John, 31, MALE]false 值得注意的是，从文件person.out中获取的Person对象与Person类中的单例对象并不相等。为了能在序列化过程仍能保持单例的特性，可以在Person类中添加一个readResolve()方法，在该方法中直接返回Person的单例对象，如下所示： 1234567891011121314151617181920212223242526272829303132public class Person implements Serializable { private static class InstanceHolder { private static final Person instatnce = new Person(\"John\", 31, Gender.MALE); } public static Person getInstance() { return InstanceHolder.instatnce; } private String name = null; private Integer age = null; private Gender gender = null; private Person() { System.out.println(\"none-arg constructor\"); } private Person(String name, Integer age, Gender gender) { System.out.println(\"arg constructor\"); this.name = name; this.age = age; this.gender = gender; } private Object readResolve() throws ObjectStreamException { return InstanceHolder.instatnce; } } 再次执行本节的SimpleSerial应用后将有如下输出： 123arg constructor[John, 31, MALE]true &ensp;&ensp; 无论是实现Serializable接口，或是Externalizable接口，当从I/O流中读取对象时，readResolve()方法都会被调用到。实际上就是用readResolve()中返回的对象直接替换在反序列化过程中创建的对象，而被创建的对象则会被垃圾回收掉。","link":"/2019/12/13/understanding-and-summary-of-java-serializable/"},{"title":"在网站中使用地图功能——调用百度地图API","text":"&lt;!DOCTYPE&nbsp;html&gt; &lt;html&gt; &lt;head&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;http-equiv=&quot;Content-Type&quot;&nbsp;content=&quot;text/html;&nbsp;charset=utf-8&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;meta&nbsp;name=&quot;viewport&quot;&nbsp;content=&quot;initial-scale=1.0,&nbsp;user-scalable=no&quot;&nbsp;/&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;style&nbsp;type=&quot;text/css&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;body,&nbsp;html,#allmap&nbsp;{width:&nbsp;100%;height:&nbsp;100%;overflow:&nbsp;hidden;margin:0;font-family:&quot;微软雅黑&quot;;} &nbsp;&nbsp;&nbsp;&nbsp;&lt;/style&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;script&nbsp;type=&quot;text/javascript&quot;&nbsp;src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=RPLo6rGFK671usuzSrxQ1H5dzwlbE8HG&quot;&gt;&lt;/script&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;title&gt;地图展示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &nbsp;&nbsp;&nbsp;&nbsp;&lt;div&nbsp;id=&quot;allmap&quot;&gt;百度地图&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &lt;script&nbsp;type=&quot;text/javascript&quot;&gt; &nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;百度地图API功能 &nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;map&nbsp;=&nbsp;new&nbsp;BMap.Map(&quot;allmap&quot;);&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;创建Map实例 &nbsp;&nbsp;&nbsp;&nbsp;map.centerAndZoom(new&nbsp;BMap.Point(113.562,&nbsp;22.260),&nbsp;15);&nbsp;&nbsp;//&nbsp;初始化地图,设置中心点坐标和地图级别 &nbsp;&nbsp;&nbsp;&nbsp;//添加地图类型控件 &nbsp;&nbsp;&nbsp;&nbsp;map.addControl(new&nbsp;BMap.MapTypeControl({ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mapTypes:[ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMAP_NORMAL_MAP, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BMAP_HYBRID_MAP &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]})); &nbsp;&nbsp;&nbsp;&nbsp;map.setCurrentCity(&quot;珠海&quot;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;设置地图显示的城市&nbsp;此项是必须设置的 &nbsp;&nbsp;&nbsp;&nbsp;map.enableScrollWheelZoom(true);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//开启鼠标滚轮缩放 &lt;/script&gt;","link":"/2017/12/05/use-map-in-websit/"},{"title":"来广州找工作的第二天","text":"来到广州的第二天，还在疯狂的投简历中，上午去了一家面试，不知道能否通过。 中午自己做了饭吃，感谢那个努力的你在我身边。接下来的一两天，得找一个短租的房子，还有就是面试、找工作。加油。。","link":"/2017/12/08/to-guangzhou-the-next-day/"},{"title":"事务的隔离级别和传播方式","text":"一、事务的四大要素 1.1 特性 1、原子性：在事务中所有的操作都是一致的，要么成功，要不不成功。 2、一致性：事务的执行使得数据库从一种正确状态转移到另一种正确的状态。事务开始和结束，数据库的完整性约束没有被破坏。 3、隔离性：在一个事务没有提交之前，其他事务不应该修改这个事务所操作的数据，没有提交的结果也不应该被其他事务读取到。 4、持久性：事务提交后的结果将保存进数据库，提交后即使数据库出现了其他故障，也应该被保存进去。 事务的作用：事务可以保证一系列的操作有序执行。保证用户的每一次操作都是可靠的，保证了后台数据的完整性。 二、事务在并发下可能出现的问题 1、脏读：指事务A读到了事务B没有提交的数据。 2、不可重复读：指某个事务两次读到的同一个数据，数据不一致的情况。 3、幻读：指在某个事务中读到了未被操作的数据。 三、事务的隔离级别 事务的隔离级别越高在并发的情况下就越安全，同时系统付出的性能代价越大。 1、default 2、read_uncommitted：读未提交，不可以防止脏读、不可重复读、幻读，一般使用较少。 3、read_committed：读已提交，可以防止脏读。不可以防止不可重读读、幻读。 4、repeatable_read：可重复读，可以防止脏读、不可重复读，不可防止幻读。读一条数据，这个事务不结束，别的事务就不可以修改这条数据。 5、串行化：可以防止脏读、幻读、不可重复读。事务串行执行，一个事务执行完了才可以执行另外一个。 mysql默认的隔离级别是repeatable_read。 四、Spring中7种事务传播类型 1、@Transactional(propagation=Propagation.REQUIRED)&nbsp; required：支持当前事务，如果当前没有事务，将会新建一个事务。 2、@Transactional(propagation=Propagation.SUPPORTS) supports：支持当前事务，如果当前没有事务，就一非事务的方式运行。 3、@Transactional(propagation=Propagation.MANDATORY)&nbsp; mandatory：强制必须有事务，如果没有事务将抛出异常。 4、@Transactional(propagation=Propagation.REQUIRES_NEW)&nbsp; requires_new：新建事务，如果当前存在事务，将此事务挂起。事务A的方法调用事务B的方法，事务B是requires_new，那么事务A将会被挂起，等事务B提交后才继续执行事务A。事务B失败了，则事务B回滚，事务A不会。失败后抛出的异常被事务A捕捉到后，事务A仍然可以事务提交成功。 5、@Transactional(propagation=Propagation.NOT_SUPPORTED)&nbsp; not_supported：已非事务方式运行，如果当前存在事务，那么将此事务挂起。等待此方法已非事务方式执行完后，再继续执行此事务。 6、@Transactional(propagation=Propagation.NEVER)&nbsp; never：不能在事务方式中运行，如果当前存在事务则抛出异常。 7、@Transactional(propagation=Propagation.PROPAGATION_NESTED)&nbsp; nested：如果当前存在事务，就嵌套在事务之中运行，如果不存在和requires_new类似。","link":"/2019/03/04/transaction-level-transmission/"},{"title":"Veloctiy语法","text":"一、基本语法1、&quot;#&quot;用来标识Velocity的脚本语句，包括#set、#if 、#else、#end、#foreach、#end、#iinclude、#parse、#macro等；如:#if($info.imgs)&lt;img src=&quot;$info.imgs&quot; border=0&gt;#else&lt;img src=&quot;noPhoto.jpg&quot;&gt;#end2、&quot;$&quot;用来标识一个对象(或理解为变量)；如如：$i、$msg、$TagUtil.options(...)等。3、&quot;{}&quot;用来明确标识Velocity变量；比如在页面中，页面中有一个$someonename，此时，Velocity将把someonename作为变量名，若我们程序是想在someone这 个变量的后面紧接着显示name字符，则上面的标签应该改成${someone}name。4、&quot;!&quot;用来强制把不存在的变量显示为空白。如当页面中包含$msg，如果msg对象有值，将显示msg的值，如果不存在msg对象同，则在页面中将显示$msg字符。这是我们不希望的，为了把不存 在的变量或变量值为null的对象显示为空白，则只需要在变量名前加一个“!”号即可。如：$!msg二、在EasyJWeb中的最佳实践&nbsp; 理论上你可以在EasyjWeb模板使用所有Velocity的脚本及功能，但我们不推荐你在界面模板中使用过多过复杂的脚本表达方式，在万不得已的情况下，不要在界面模板中加入任何复杂的逻辑，更不要在界面模板中加入变量声明、逻辑运算符等等。 在EasyJWeb中，我们提供了五条基本的模板脚本语句，基本上就能满足所有应用模板的要求。这四条模板语句很简单，可以直接由界面设计人员来添加。在当前很多EasyJWeb的应用实践中，我们看到，所有界面模板中归纳起来只有下面四种简单模板脚本语句即可实现：1、$!obj 直接返回对象结果。如：在html标签中显示java对象msg的值。&lt;p&gt;$!msg&lt;/p&gt;在html标签中显示经过HtmlUtil对象处理过后的msg对象的值 &lt;p&gt;$!HtmlUtil.doSomething($!msg)&lt;/p&gt; 2、#if($!obj) #else #end 判断语句如：在EasyJWeb各种开源应用中，我们经常看到的用于弹出提示信息msg的例子。#if($msg)&lt;script&gt;alert('$!msg');&lt;/script&gt;#end上面的脚本表示当对象msg对象存在时，输出&lt;script&gt;等后面的内容。3、#foreach( $info in $list) $info.someList #end 循环读取集合list中的对象，并作相应的处理。如：EasyJF开源论坛系统中论(0.3)坛首页显示热门主题的html界面模板脚本：#foreach( $info in $hotList1)&nbsp;&lt;a href=&quot;/bbsdoc.ejf?easyJWebCommand=show&amp;&amp;cid=$!info.cid&quot; target=&quot;_blank&quot;&gt;$!info.title&lt;/a&gt;&lt;br&gt;#end&nbsp;上面的脚本表示循环遍历hotList1集合中的对象，并输出对象的相关内容。4、#macro(macroName)#end 脚本函数(宏)调用，不推荐在界面模板中大量使用。如：在使用EasyJWeb Tools快速生成的添删改查示例中，可以点击列表的标题栏进行升降排序显示，这是我们在EasyJWeb应用中经常看到的一个排序状态显示的模板内容。函数(宏)定义，一般放在最前面#macro(orderPic $type)#if ($orderField.equals($type))&nbsp;&lt;img src=&quot;http://images.cnblogs.com/ico/${orderType}.gif&quot;&gt;&nbsp;#end#end具体的调用如：&lt;font color=&quot;#FFFFFF&quot;&gt;头衔#orderPic(&quot;title&quot;)&lt;/font&gt;经过测试，宏不支持方法重载5、包含文件#inclue(&quot;模板文件名&quot;)或#parse(&quot;模板文件名&quot;)主要用于处理具有相同内容的页面，比如每个网站的顶部或尾部内容。使用方法，可以参考EasyJF开源Blog及EasyJF开源论坛中的应用！如：#parse(&quot;/blog/top.html&quot;)或#include(&quot;/blog/top.html&quot;)parse与include的区别在于，若包含的文件中有Velocity脚本标签，将会进一步解析，而include将原样显示。三、关于#set的使用在万不得已的时候，不要在页面视图自己声明Velocity脚本变量，也就是尽量少使用#set。有时候我们需要在页面中显示序号，而程序对象中又没有包 含这个序号属性同，可以自己定义。如在一个循环体系中，如下所示：#set ($i=0)#foreach($info in $list)序号:$i#set($i=$i+1)#end四、Velocity脚本语法摘要1、声明:#set ($var=XXX)左边可以是以下的内容Variable reference&nbsp;String literal&nbsp;Property reference&nbsp;Method reference&nbsp;Number literal #set ($i=1)&nbsp;ArrayList #set ($arr=[&quot;yt1&quot;,&quot;t2&quot;])算术运算符2、注释:单行## XXX多行#* xxxxxxxxxxxxxxxxxxx*#References 引用的类型3、变量 Variables&nbsp;以 &quot;$&quot; 开头，第一个字符必须为字母。character followed by a VTL Identifier. (a .. z or A .. Z).变量可以包含的字符有以下内容：alphabetic (a .. z, A .. Z)&nbsp;numeric (0 .. 9)&nbsp;hyphen (&quot;-&quot;)&nbsp;underscore (&quot;_&quot;)&nbsp;4、Properties&nbsp;$Identifier.Identifier$user.namehashtable user中的的name值.类似：user.get(&quot;name&quot;)5、Methods&nbsp;object user.getName() = $user.getName()6、Formal Reference Notation&nbsp;用{}把变量名跟字符串分开&nbsp;如#set ($user=&quot;csy&quot;}${user}name&nbsp;返回csyname$username$!username$与$!的区别当找不到username的时候，$username返回字符串&quot;$username&quot;，而$!username返回空字符串&quot;&quot;&nbsp;7、双引号 与 引号&nbsp;#set ($var=&quot;helo&quot;)test&quot;$var&quot; 返回testhellotest'$var' 返回test'$var'可以通过设置 stringliterals.interpolate=false改变默认处理方式8、条件语句#if( $foo )&nbsp;&lt;strong&gt;Velocity!&lt;/strong&gt;#end#if($foo)#elseif()#else#end当$foo为null或为Boolean对象的false值执行.9、逻辑运算符:== &amp;&amp; || !10、循环语句#foreach($var in $arrays ) // 集合包含下面三种Vector, a Hashtable or an Array#end#foreach( $product in $allProducts )&lt;li&gt;$product&lt;/li&gt;#end#foreach( $key in $allProducts.keySet() )&lt;li&gt;Key: $key -&gt; Value: $allProducts.get($key)&lt;/li&gt;#end#foreach( $customer in $customerList )&lt;tr&gt;&lt;td&gt;$velocityCount&lt;/td&gt;&lt;td&gt;$customer.Name&lt;/td&gt;&lt;/tr&gt;#end11、velocityCount变量在配置文件中定义# Default name of the loop counter# variable reference.directive.foreach.counter.name = velocityCount# Default starting value of the loop# counter variable reference.directive.foreach.counter.initial.value = 112、包含文件&nbsp;#include( &quot;one.gif&quot;,&quot;two.txt&quot;,&quot;three.htm&quot; )13、Parse导入脚本#parse(&quot;me.vm&quot; )14、#stop 停止执行并返回&nbsp;15、定义宏Velocimacros ,相当于函数 支持包含功能#macro( d )&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;#end调用&nbsp;#d()16、带参数的宏#macro( tablerows $color $somelist )#foreach( $something in $somelist )&lt;tr&gt;&lt;td bgcolor=$color&gt;$something&lt;/td&gt;&lt;/tr&gt;#end#end17、Range Operator&nbsp;#foreach( $foo in [1..5] )附：《浅析MVC框架中View层的优雅设计及实例》作者：EasyJF开源团队 大峡在基于B/S的应用程序开发中，从基本的技术分工上来说就是两大块，一是软件显示界面，另一个是程序逻辑。在N年前的脚本语言时代，无论是asp、 php还是jsp，我们基本是都是把这两者柔和在一起的。尽管我们想方设法做好很多函数或者包含文件来努力达到软件的复用，但仍然无法满足多变的用户需 求,这主要是因为以前的纯脚本编码方式无法很好支持及应用面向对象(OO)领域中的强大功能。在常见的B/S软件项目中，界面的设计包括html界面、Wap界面及其它由文本字符协议为基本表示的界面等。以我们接触最多的html页面为例子，在 做这些界面的时候往往需要美工先使用photoshop或fireworks等图形界面设计工具进行全局设计，然后再使用进行Dreamweaver等 html页面制作工具进行加工制作。而强大的程序逻辑及后台处理都是由服务器端程序完成，这些程序具有较高的稳定性，其开发工具如JBuilder、 Eclipse等对View层的界面无法很好的支持(当然那些用记事本写界面的应用除外)，这就使得很多MVC框架的设计都无法两全齐美。作位一个比较友好的MVC的框架，在简化服务器应用开发的同时，还需要在View这一层设计上不要过多的影响到界面人员的工作，最基本的要求就是不要过 多的加入一些设计软件不支持的标签等元素(如Struts的很多标签在Dreamweaver中都不支持)。这里我们以EasyJWeb为例，探讨在 View层如何实现比较合理的设计。 EasyJWeb作为一个快速Java Web MVC框架，其设计目标不尽是要简化软件开发人员的代码书写工作，更是要能方便界面设计人员的工作。 当然，要使界面能跟后台程序逻辑能融合，显示界面及程序逻辑之间需要一定的对话协议在所难免。EasyJWeb作为一个MVC框架，同样也存在着这样的对话协议，这就是EasyJWeb中的界面模板标识语言。 在当前发布的版本中，EasyJWeb界面模板标识语言使用的是Apache开源的Velocity模板引擎(template engine)，当然以后会根据际需要加入更多的模板引擎以供框架应用者选择。Velocity是一个基于java的模板引擎（template engine），它允许任何人仅仅简单的使用模板语言（template language）来引用由java代码定义的对象。作为一个比较完善的模板引擎，Velocity的功能是比较强大的，但强大的同时也增加了应用复杂 性。 理论上你可以在EasyjWeb模板使用所有Velocity的脚本及功能，但我们不推荐你在界面模板中使用过多过复杂的脚本表达方式，在万不得已的情况下，不要在界面模板中加入任何复杂的逻辑，更不要在界面模板中加入变量声明、逻辑运算符等等。 在EasyJWeb中，我们提供了四条基本的模板脚本语句，基本上就能满足所有应用模板的要求。这四条模板语句很简单，可以直接由界面设计人员来添加。在当前很多EasyJWeb的应用实践中，我们看到，所有界面模板中归纳起来只有下面四种简单模板脚本语句即可实现： 1、$!obj 直接返回对象结果。如：在html标签中显示java对象msg的值。&lt;p&gt;$!msg&lt;/p&gt;在html标签中显示经过HtmlUtil对象处理过后的msg对象的值.&lt;p&gt;$!HtmlUtil.doSomething($!msg)&lt;/p&gt; 2、#if($!obj) #else #end 判断语句 如：在EasyJWeb各种开源应用中，我们经常看到的用于弹出提示信息msg的例子。#if($msg)&lt;script&gt;alert('$!msg');&lt;/script&gt;#end上面的脚本表示当对象msg对象存在时，输出&lt;script&gt;等后面的内容。 3、#foreach( $info in $list) $info.something #end 循环读取集合list中的对象，并作相应的处理。如：EasyJF开源论坛系统中论坛首页显示热门主题的html界面模板脚本 #foreach( $info in $hotList1)&nbsp;&lt;a href=&quot;/bbsdoc.ejf?easyJWebCommand=show&amp;&amp;cid=$!info.cid&quot; target=&quot;_blank&quot;&gt;$!info.title&lt;/a&gt;&lt;br&gt;#end&nbsp;上面的脚本表示循环遍历hotList1集合中的对象，并输出对象的相关内容。4、#macro(macroName)#end 脚本函数(宏)调用，不推荐在界面模板中大量使用。 如：在EasyJF简易订销管等系统中经常看到的一个排序状态显示的模板内容。函数(宏)定义，一般放在最前面#macro(orderPic $type)#if ($orderField.equals($type))&nbsp;&lt;img src=&quot;http://images.cnblogs.com/ico/${orderType}.gif&quot;&gt;&nbsp;#end#end具体的调用如：&lt;font color=&quot;#FFFFFF&quot;&gt;头衔#orderPic(&quot;title&quot;)&lt;/font&gt;&nbsp;总结： 当然，在实际应用项目中，为了实现界面的更加友好、人性化，会出现很多复、易变的需求。如根据对象的不同状态，显示不同的提示颜色、提示语音等功能。在这 种时候，仍然要慎用太多的模板脚本功能，大多数需求都可以通过变通的方式解决，有些信息可以直接在对象中增加逻辑转化信息，有些界面要求可以通过在界面中 使用与特定界面有关的表达方式来实现，如html页面中使用javascript、css，Wap页面中使用WMLScript等等。只有，这样才能确保 证你的系统核心不受界面的的影响及控制，才能更好的扩展及维护。 我们希望你能成为真正的程序高手，而不只是精通某个处于表层的脚本语言，因此也不希望广大Java开发人员在View层消耗太多的时间。 由于水平有限，本文所谈的内容有N多不合理或者需要改进的地方，恳请大家指正！附：EasyJWeb简介EasyJWeb是基于java技术，应用于WEB应用程序快速开发的MVC框架，框架设计构思来源于国内众多项目实践，充分借签了当前主流的开源 Web框架（Struts、JSF、Tapestry 、Webwork等），吸取了其优点及精华，利用Velocity作为模板页面引擎，是一个实现了页面及代码完全分离的MVC开发框架，是一个旨在于为中 小型Web应用系统提供快速开发实践的简易Web框架。 EasyJF开源团队于2006年初才开始建设，因此当前整个开发团队组建以及所发布的作品，都显得极不成熟。EasyJWeb仍然处于测试阶段，请广大的Java爱好者多多批评及建议,同时也非常欢迎您能加入到我们的国产开源队伍中。EasyJWeb官方网址：www.easyjf.comEasyJF团队官方网址：www.easyjf.com转载自：https://www.cnblogs.com/likwo/archive/2010/05/13/1734936.html","link":"/2017/12/19/velocity-expression-syntax/"},{"title":"事务的定义、作用和Spring的事物配置","text":"(1):事务（Transaction）是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。通过事务，SQL Server能将逻辑相关的一组操作绑定在一起，以便服务器保持数据的完整性。(2):事务通常是以BEGIN TRANSACTION开始，以COMMIT或ROLLBACK结束。COMMIT表示提交，即提交事务的所有操作。具体地说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束。ROLLBACK表示回滚，即在事务运行的过程中发生了某种故障，事务不能继续进行，系统将事务中对数据库的所有以完成的操作全部撤消，滚回到事务开始的状态。(3):事务运行的三种模式:A:自动提交事务&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 每条单独的语句都是一个事务。每个语句后都隐含一个COMMIT。B:显式事务&nbsp; &nbsp; &nbsp; &nbsp;以BEGIN TRANSACTION显式开始，以COMMIT或ROLLBACK显式结束。C:隐性事务&nbsp; &nbsp; &nbsp; &nbsp;在前一个事务完成时，新事务隐式启动，但每个事务仍以COMMIT或ROLLBACK显式结束。(4):事务的特性(ACID特性)A:原子性(Atomicity)&nbsp; &nbsp; &nbsp; &nbsp;事务是数据库的逻辑工作单位，事务中包括的诸操作要么全做，要么全不做。B:一致性(Consistency)&nbsp; &nbsp; &nbsp; &nbsp;事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。C:隔离性(Isolation)&nbsp; &nbsp; &nbsp; 一个事务的执行不能被其他事务干扰。D:持续性/永久性(Durability)&nbsp; &nbsp; &nbsp; 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。注:事务是恢复和并发控制的基本单位。事物管理对于企业应用来说是至关重要的，好使出现异常情况，它也可以保证数据的一致性。spring支持编程式事务管理和声明式事务管理两种方式。编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。&nbsp;声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。显然声明式事务管理要优于编程式事务管理，这正是spring倡导的非侵入式的开发方式。声明式事务管理使业务代码不受污染，一个普通的POJO对象，只要加上注解就可以获得完全的事务支持。和编程式事务相比，声明式事务唯一不足地方是，后者的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。但是即便有这样的需求，也存在很多变通的方法，比如，可以将需要进行事务管理的代码块独立为方法等等。声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。spring事务特性spring所有的事务管理策略类都继承自org.springframework.transaction.PlatformTransactionManager接口其中TransactionDefinition接口定义以下特性：事务隔离级别&nbsp; 隔离级别是指若干个并发的事务之间的隔离程度。TransactionDefinition 接口中定义了五个表示隔离级别的常量：TransactionDefinition.ISOLATION_DEFAULT：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED。TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。事务传播行为所谓事务的传播行为是指，如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：TransactionDefinition.PROPAGATION_REQUIRED：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值。TransactionDefinition.PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。TransactionDefinition.PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。TransactionDefinition.PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。TransactionDefinition.PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。TransactionDefinition.PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。事务超时所谓事务超时，就是指一个事务所允许执行的最长时间，如果超过该时间限制但事务还没有完成，则自动回滚事务。在 TransactionDefinition 中以 int 的值来表示超时时间，其单位是秒。默认设置为底层事务系统的超时值，如果底层数据库事务系统没有设置超时值，那么就是none，没有超时限制。事务只读属性&nbsp; &nbsp; &nbsp;只读事务用于客户代码只读但不修改数据的情形，只读事务用于特定情景下的优化，比如使用Hibernate的时候。默认为读写事务。&nbsp;&nbsp;&nbsp;&nbsp;“只读事务”并不是一个强制选项，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。&nbsp;但是你非要在“只读事务”里面修改数据，也并非不可以，只不过对于数据一致性的保护不像“读写事务”那样保险而已。&nbsp;因此，“只读事务”仅仅是一个性能优化的推荐配置而已，并非强制你要这样做不可spring事务回滚规则&nbsp; &nbsp; &nbsp;指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常。spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务。&nbsp; &nbsp; &nbsp;默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。可以明确的配置在抛出那些异常时回滚事务，包括checked异常。也可以明确定义那些异常抛出时不回滚事务。还可以编程性的通过setRollbackOnly()方法来指示一个事务必须回滚，在调用完setRollbackOnly()后你所能执行的唯一操作就是回滚。myBatis为例 &nbsp; 基于注解的声明式事务管理配置@Transactionalspring.xml&lt;span&nbsp;style=&quot;background-color:&nbsp;rgb(255,&nbsp;255,&nbsp;255);&quot;&gt;&lt;span&nbsp;style=&quot;background-color:&nbsp;rgb(255,&nbsp;204,&nbsp;153);&quot;&gt;&lt;!--&nbsp;mybatis&nbsp;config&nbsp;--&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;sqlSessionFactory&quot;&nbsp;class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;dataSource&quot;&nbsp;ref=&quot;dataSource&quot;&nbsp;/&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;configLocation&quot;&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;classpath:mybatis-config.xml&lt;/value&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;mybatis&nbsp;mappers,&nbsp;scanned&nbsp;automatically&nbsp;--&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;basePackage&quot;&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;com.baobao.persistence.test&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/value&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/property&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;sqlSessionFactory&quot;&nbsp;ref=&quot;sqlSessionFactory&quot;&nbsp;/&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;配置spring的PlatformTransactionManager，名字为默认值&nbsp;--&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;transactionManager&quot;&nbsp;class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;dataSource&quot;&nbsp;ref=&quot;dataSource&quot;&nbsp;/&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;!--&nbsp;开启事务控制的注解支持&nbsp;--&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;tx:annotation-driven&nbsp;transaction-manager=&quot;transactionManager&quot;/&gt;&lt;/span&gt;&lt;/span&gt;添加tx名字空间&lt;span&nbsp;style=&quot;background-color:&nbsp;rgb(255,&nbsp;255,&nbsp;255);&quot;&gt;&lt;span&nbsp;style=&quot;background-color:&nbsp;rgb(255,&nbsp;204,&nbsp;153);&quot;&gt; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;&nbsp;xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;&nbsp;&nbsp; &nbsp;&nbsp; xsi:schemaLocation=&quot;http://www.springframework.org/schema/aop&nbsp;http://www.springframework.org/schema/aop/spring-aop-3.0.xsd&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;http://www.springframework.org/schema/tx&nbsp;http://www.springframework.org/schema/tx/spring-tx-3.0.xsd&quot;&lt;/span&gt;&lt;/span&gt;MyBatis自动参与到spring事务管理中，无需额外配置，只要org.mybatis.spring.SqlSessionFactoryBean引用的数据源与DataSourceTransactionManager引用的数据源一致即可，否则事务管理会不起作用。@Transactional注解@Transactional属性&nbsp;&nbsp; &nbsp;属性&nbsp; &nbsp;类型&nbsp; &nbsp;描述valueString可选的限定描述符，指定使用的事务管理器propagationenum: Propagation可选的事务传播行为设置isolationenum: Isolation可选的事务隔离级别设置readOnlyboolean读写或只读事务，默认读写timeoutint (in seconds granularity)事务超时时间设置rollbackForClass对象数组，必须继承自Throwable导致事务回滚的异常类数组rollbackForClassName类名数组，必须继承自Throwable导致事务回滚的异常类名字数组noRollbackForClass对象数组，必须继承自Throwable不会导致事务回滚的异常类数组noRollbackForClassName类名数组，必须继承自Throwable不会导致事务回滚的异常类名字数组用法&nbsp; &nbsp; &nbsp; &nbsp;@Transactional 可以作用于接口、接口方法、类以及类方法上。当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。&nbsp; &nbsp; &nbsp; &nbsp;虽然 @Transactional 注解可以作用于接口、接口方法、类以及类方法上，但是 Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效。另外， @Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。如果你在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常。&nbsp; &nbsp; &nbsp; &nbsp;默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰。@Autowired&nbsp;&nbsp; private&nbsp;MyBatisDao&nbsp;dao;&nbsp;&nbsp; &nbsp;&nbsp; @Transactional&nbsp;&nbsp; @Override&nbsp;&nbsp; public&nbsp;void&nbsp;insert(Test&nbsp;test)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;dao.insert(test);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException(&quot;test&quot;);//抛出unchecked异常，触发事物，回滚&nbsp;&nbsp; }noRollbackFor@Transactional(noRollbackFor=RuntimeException.class)&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert(Test&nbsp;test)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dao.insert(test);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抛出unchecked异常，触发事物，noRollbackFor=RuntimeException.class,不回滚&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException(&quot;test&quot;);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}类，当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性@Transactional&nbsp;&nbsp; public&nbsp;class&nbsp;MyBatisServiceImpl&nbsp;implements&nbsp;MyBatisService&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;@Autowired&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;private&nbsp;MyBatisDao&nbsp;dao;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;@Override&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;insert(Test&nbsp;test)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dao.insert(test);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//抛出unchecked异常，触发事物，回滚&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw&nbsp;new&nbsp;RuntimeException(&quot;test&quot;);&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;}propagation=Propagation.NOT_SUPPORTED@Transactional(propagation=Propagation.NOT_SUPPORTED)&nbsp;&nbsp; @Override&nbsp;&nbsp; public&nbsp;void&nbsp;insert(Test&nbsp;test)&nbsp;{&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;//事物传播行为是PROPAGATION_NOT_SUPPORTED，以非事务方式运行，不会存入数据库&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;dao.insert(test);&nbsp;&nbsp; }myBatis为例 &nbsp; 基于注解的声明式事务管理配置,xml配置主要为aop切面配置，只看xml就可以了&lt;!--&nbsp;事物切面配置&nbsp;--&gt;&nbsp;&nbsp; &lt;tx:advice&nbsp;id=&quot;advice&quot;&nbsp;transaction-manager=&quot;transactionManager&quot;&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;tx:attributes&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tx:method&nbsp;name=&quot;update*&quot;&nbsp;propagation=&quot;REQUIRED&quot;&nbsp;read-only=&quot;false&quot;&nbsp;rollback-for=&quot;java.lang.Exception&quot;/&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;tx:method&nbsp;name=&quot;insert&quot;&nbsp;propagation=&quot;REQUIRED&quot;&nbsp;read-only=&quot;false&quot;/&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;/tx:attributes&gt;&nbsp;&nbsp; &lt;/tx:advice&gt;&nbsp;&nbsp; &nbsp;&nbsp; &lt;aop:config&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;aop:pointcut&nbsp;id=&quot;testService&quot;&nbsp;expression=&quot;execution&nbsp;(*&nbsp;com.baobao.service.MyBatisService.*(..))&quot;/&gt;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&lt;aop:advisor&nbsp;advice-ref=&quot;advice&quot;&nbsp;pointcut-ref=&quot;testService&quot;/&gt;&nbsp;&nbsp; &lt;/aop:config&gt;转载自[1]：http://blog.csdn.net/zhikun518/article/details/7185155转载自[2]：http://blog.csdn.net/bao19901210/article/details/41724355","link":"/2017/12/11/transaction-definition-effect-spring-tran/"},{"title":"VeloCity的简单使用","text":"在idea中使用veloctiy 1.导入jar包从官网下载下来最新的veloctiy我只导入了上面红色框框中的jar包2.在resources文件下加入veloctiy.properties和toolbox.xml配置文件3.在准备一个简单的.vm文件验证其可以使用","link":"/2017/12/19/velocity-simple-use-in-idea/"},{"title":"vue中在页面渲染完之后获取元素","text":"两种方法 方法一：使用$nextTick，在异步获得数据之后再获取元素 &nbsp; 方法二：在then之后再获取该元素 .then(function (response) { _self.topic = response.data;}).then(()=&gt;{ if(!GenerateContentList()){ _self.showMenuCard = false;} 我用的方法二 &nbsp; &nbsp; 参考&gt;&gt;&gt;","link":"/2019/06/01/vue-get-element-after-rendering/"}],"tags":[{"name":"记录一下","slug":"记录一下","link":"/tags/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8B/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"activemq","slug":"activemq","link":"/tags/activemq/"},{"name":"微服务","slug":"微服务","link":"/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"有道云笔记","slug":"有道云笔记","link":"/tags/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"dubbo","slug":"dubbo","link":"/tags/dubbo/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"Mysql","link":"/tags/Mysql/"},{"name":"Element UI","slug":"Element-UI","link":"/tags/Element-UI/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"ElasticSearch","slug":"ElasticSearch","link":"/tags/ElasticSearch/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"FreeMarker","slug":"FreeMarker","link":"/tags/FreeMarker/"},{"name":"Hibernate","slug":"Hibernate","link":"/tags/Hibernate/"},{"name":"面试","slug":"面试","link":"/tags/%E9%9D%A2%E8%AF%95/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Json","slug":"Json","link":"/tags/Json/"},{"name":"markdown","slug":"markdown","link":"/tags/markdown/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"中间件","slug":"中间件","link":"/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"},{"name":"redis","slug":"redis","link":"/tags/redis/"},{"name":"软件工程","slug":"软件工程","link":"/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"Resin","slug":"Resin","link":"/tags/Resin/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"Ubuntu","slug":"Ubuntu","link":"/tags/Ubuntu/"},{"name":"Rbenv","slug":"Rbenv","link":"/tags/Rbenv/"},{"name":"Ruby","slug":"Ruby","link":"/tags/Ruby/"},{"name":"UEditor","slug":"UEditor","link":"/tags/UEditor/"},{"name":"velocity","slug":"velocity","link":"/tags/velocity/"},{"name":"事务","slug":"事务","link":"/tags/%E4%BA%8B%E5%8A%A1/"},{"name":"idea","slug":"idea","link":"/tags/idea/"}],"categories":[{"name":"ElasticSearch系列","slug":"ElasticSearch系列","link":"/categories/ElasticSearch%E7%B3%BB%E5%88%97/"},{"name":"生活","slug":"生活","link":"/categories/%E7%94%9F%E6%B4%BB/"}]}